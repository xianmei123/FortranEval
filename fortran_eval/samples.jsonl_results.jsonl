{"task_id": "test/0", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION has_close_elements(numbers, threshold) RESULT(result)\n        IMPLICIT NONE\n        REAL, DIMENSION(:), INTENT(IN) :: numbers\n        REAL,INTENT(IN) :: threshold \n        INTEGER :: size0, N, M\n        LOGICAL :: result\n        result = .FALSE.\n        size0 = SIZE(numbers)\n\n        DO N = 1, SIZE(numbers),1\n            DO M = N+1,size0,1\n                IF(ABS(numbers(M)-numbers(N))<threshold) THEN\n                    result = .TRUE.\n                    EXIT\n                    END IF\n                END DO\n            END DO\n        END FUNCTION has_close_elements\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09137487411499023}
{"task_id": "test/2", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION truncate_number(number) RESULT(result)\n        IMPLICIT NONE\n        REAL,INTENT(IN) :: number\n        REAL :: result\n        result = number - REAL(INT(number))\n        END FUNCTION truncate_number\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09496378898620605}
{"task_id": "test/3", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION below_zero(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER :: len, N, tmp\n        LOGICAL :: result\n        result = .FALSE.\n        tmp=0\n        len = SIZE(numbers)\n\n        DO N = 1, len,1\n            IF(tmp+numbers(N)<0) THEN\n                result = .TRUE.\n                EXIT\n            ELSE\n                tmp = tmp + numbers(N)\n            END IF\n        END DO\n    END FUNCTION below_zero\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09357905387878418}
{"task_id": "test/4", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION mean_absolute_deviation(numbers) RESULT(result)\n        IMPLICIT NONE\n        REAL, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER :: len, N\n        REAL :: result, means\n        result = 0.0\n        len = SIZE(numbers)\n        means = SUM(numbers)/REAL(len)\n\n        DO N = 1, len,1\n            result=result+ABS(numbers(N)-means)\n        END DO\n        result = result/REAL(len)\n        END FUNCTION mean_absolute_deviation\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09422445297241211}
{"task_id": "test/5", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION mean_absolute_deviation(numbers, delimeter) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, INTENT(IN) :: delimeter\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n\n        len = SIZE(numbers)\n        If(len == 1) THEN\n            ALLOCATE(result(len))\n            result(1) = numbers(1)\n        ELSE IF(len >= 2) THEN\n            ALLOCATE(result(len*2-1))\n            DO N=1,len-1,1\n                result(2*N-1)=numbers(N)\n                result(2*N)=delimeter\n            END DO\n            result(2*len-1)=numbers(len)\n        ELSE\n        END IF\n        END FUNCTION mean_absolute_deviation\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09381937980651855}
{"task_id": "test/8", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION sum_product(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(2) :: result\n        INTEGER :: len, N,tmp,sum0\n        tmp = 1\n        sum0 = SUM(numbers)\n        len = SIZE(numbers)\n        DO N = 1, len,1\n            tmp=tmp*numbers(N)\n        END DO\n        result(1)=sum0\n        result(2)=tmp\n        END FUNCTION sum_product\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.0970759391784668}
{"task_id": "test/9", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION rolling_max(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N, maxn\n        maxn = numbers(1)\n        len = SIZE(numbers)\n        ALLOCATE(result(len))\n        \n        DO N=1,len,1\n            maxn=MAX(maxn,numbers(N))\n            result(N)=maxn\n        END DO\n        END FUNCTION rolling_max\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09791803359985352}
{"task_id": "test/13", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION greatest_common_divisor(a, b) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: a, b\n        INTEGER:: result, tmp1, tmp2\n        tmp1 = a\n        tmp2 = b\n        DO WHILE(tmp2/=0)\n            result=tmp2\n            tmp2=MOD(tmp1,tmp2)\n            tmp1=result\n        END DO\n        result=tmp1\n        END FUNCTION greatest_common_divisor\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09455132484436035}
{"task_id": "test/21", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION rescale_to_unit(numbers) RESULT(result)\n        IMPLICIT NONE\n        REAL, DIMENSION(:), INTENT(IN) :: numbers\n        REAL, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n        REAL :: maxn, minn\n        maxn = numbers(1)\n        minn = numbers(1)\n        len = SIZE(numbers)\n        ALLOCATE(result(len))\n        \n        DO N=1,len,1\n            maxn=MAX(maxn,numbers(N))\n            minn=MIN(minn,numbers(N))\n            \n        END DO\n        DO N=1,len,1\n            result(N)=(numbers(n)-minn)/(maxn-minn)\n        END DO\n        END FUNCTION rescale_to_unit\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09969782829284668}
{"task_id": "test/24", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION largest_divisor(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: result\n        result = n/2 +1\n\n        DO WHILE(MOD(n,result)>0)\n            result = result - 1\n        END DO\n        END FUNCTION largest_divisor\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09752106666564941}
{"task_id": "test/25", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION factorize(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: i,maxn,tmp,len\n        i=2\n        len=0\n        maxn=INT(SQRT(REAL(n))+1)\n        tmp=n\n        DO WHILE(i<=maxn)\n            IF(tmp<i) THEN\n                EXIT\n            END IF\n            IF(MOD(tmp,i)==0) THEN\n                tmp=INT(tmp/i)\n                len=len+1\n            ELSE\n                i=i+1\n            END IF\n        END DO\n        IF(tmp > 1) THEN\n            len=len+1\n        END IF\n        ALLOCATE(result(len))\n        tmp=n\n        i=2\n        len=0\n        DO WHILE(i<=maxn)\n            IF(MOD(tmp,i)==0) THEN\n                tmp=INT(tmp/i)\n                result(len+1)=i\n                len=len+1\n            ELSE\n                i=i+1\n            END IF\n        END DO\n        IF(tmp > 1) THEN\n            result(len+1)=tmp;\n        END IF\n        END FUNCTION factorize\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09736418724060059}
{"task_id": "test/26", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result, arr\n        INTEGER :: len, N, count,M,tmp\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=0\n        END DO\n        DO N=1,len,1\n            IF(arr(N)==0) THEN\n                tmp=count\n                DO M=N+1,len,1\n                    IF(numbers(N)==numbers(M)) THEN\n                        arr(M)=1\n                        count=count+1\n                    END IF\n                END DO\n                IF(tmp/=count) THEN\n                    arr(N)=1\n                    count=count+1\n                END IF\n            END IF\n        END DO\n        ALLOCATE(result(len-count))\n        M=1\n        DO N=1,len,1\n            IF(arr(N)==0) THEN\n                result(M)=numbers(N)\n                M=M+1\n            END IF\n        END DO\n        END FUNCTION remove_duplicates\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.10974955558776855}
{"task_id": "test/31", "completion": "MODULE test_module\n CONTAINS\n FUNCTION is_prime(n) RESULT(result)\n IMPLICIT NONE\n INTEGER, INTENT(IN) :: n\n LOGICAL :: result\n INTEGER :: k\n result=.TRUE.\n IF(n<2) THEN\n result=.False.\n ELSE IF(n==2) THEN\n result = .TRUE.\n ELSE\n DO k=2,N/2+1,1\n IF(MOD(n,k)==0) THEN\n result=.False.\n EXIT\n END IF\n END DO\n END IF\n END FUNCTION is_prime\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.12457776069641113}
{"task_id": "test/34", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result, arr\n        INTEGER :: len, N, count,M,tmp\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=numbers(N)\n        END DO\n\n        DO WHILE(len > 1)\n            DO M=2,len,1\n                IF(arr(M-1)>arr(M)) THEN\n                    tmp=arr(M)\n                    arr(M)=arr(M-1)\n                    arr(M-1)=tmp\n                END IF\n            END DO\n            len=len-1\n        END DO\n        len=SIZE(numbers)\n        DO N=2,len,1\n            IF(arr(N)==arr(N-1)) THEN\n                count=count+1\n            END IF\n        END DO\n        ALLOCATE(result(len-count))\n        M=2\n        result(1)=arr(1)\n        DO N=2,len,1\n            IF(arr(N)/=arr(N-1)) THEN\n                result(M)=arr(N)\n                M=M+1\n            END IF\n        END DO\n\n        END FUNCTION remove_duplicates\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.11869096755981445}
{"task_id": "test/35", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION max_element(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER :: result\n        INTEGER :: len, N\n        result = numbers(1)\n        len = SIZE(numbers)\n        \n        DO N=1,len,1\n            result=MAX(result,numbers(N))\n            \n        END DO\n\n        END FUNCTION max_element\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.11758613586425781}
{"task_id": "test/36", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION fizz_buzz(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: numbers\n        INTEGER :: result\n        INTEGER :: N,tmp\n        result = 0\n        \n        DO N=11,numbers-1,1\n            IF(MOD(N,11)==0 .OR. MOD(N,13)==0) THEN\n                tmp = N\n                DO WHILE(tmp/=0)\n                    IF(MOD(tmp,10)==7) THEN\n                        \n                        result=result+1\n                        \n                    END IF\n                    tmp=tmp/10\n                END DO\n            END IF\n            \n        END DO\n\n        END FUNCTION fizz_buzz\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.1251983642578125}
{"task_id": "test/37", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(arr)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: arr\n        INTEGER :: len, N, count,M,tmp\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=numbers(N)\n        END DO\n\n        DO WHILE(len > 1)\n            DO M=3,len,2\n                IF(arr(M-2)>arr(M)) THEN\n                    tmp=arr(M)\n                    arr(M)=arr(M-2)\n                    arr(M-2)=tmp\n                END IF\n            END DO\n            len=len-2\n        END DO\n        \n        END FUNCTION remove_duplicates\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.11365175247192383}
{"task_id": "test/39", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION is_prime(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        LOGICAL :: result\n        INTEGER :: k\n        result=.TRUE.\n        IF(n<2) THEN\n            result=.False.\n        ELSE IF(n==2) THEN\n            result = .TRUE.\n        ELSE\n            DO k=2,n/2+1,1\n                IF(MOD(n,k)==0) THEN\n                    result=.False.\n                    EXIT\n                END IF\n            END DO\n        END IF\n        END FUNCTION is_prime\n\n        FUNCTION prime_fib(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            INTEGER :: k, tmp1, tmp2\n            tmp1 = 1\n            tmp2 = 1\n            k = 0\n            DO WHILE(k /= n)\n                result = tmp1+tmp2\n                tmp1 = tmp2\n                tmp2 = result\n                IF(is_prime(result)) THEN\n                    k=k+1\n                END IF\n            END DO\n\n            END FUNCTION prime_fib\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.7929494380950928}
{"task_id": "test/40", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION triples_sum_to_zero(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        LOGICAL :: result\n        INTEGER :: len, N, M, K\n        len = SIZE(numbers)\n        result=.FALSE.\n        \n        DO N=1,len,1\n            DO M=N+1,len,1\n                DO K=M+1,len,1\n                    IF(numbers(N)+numbers(M)+numbers(K)==0) THEN\n                        result=.TRUE.\n                        EXIT\n                    END IF\n                END DO\n            END DO\n        END DO\n        END FUNCTION triples_sum_to_zero\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.11632418632507324}
{"task_id": "test/41", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION car_race_collision(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            result = n*n\n            END FUNCTION car_race_collision\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.11680102348327637}
{"task_id": "test/42", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION incr_list(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n        \n        len = SIZE(numbers)\n        ALLOCATE(result(len))\n        \n        DO N=1,len,1\n            \n            result(N)=numbers(n)+1\n        END DO\n        END FUNCTION incr_list\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09070467948913574}
{"task_id": "test/45", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION triangle_area(a, h) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: a, h\n            REAL :: result\n            result = REAL(a)*REAL(h)/2\n            END FUNCTION triangle_area\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09655547142028809}
{"task_id": "test/46", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION fib4(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            INTEGER :: k, tmp1, tmp2, tmp3, tmp0\n            tmp0 = 0\n            tmp1 = 0\n            tmp2 = 2\n            tmp3 = 0\n            \n            IF(n==0) THEN\n                result=tmp0\n            ELSE IF(n==1) THEN\n                result=tmp1\n            ELSE IF(n==2) THEN\n                result=tmp2\n            ELSE IF(n==3) THEN\n                result=tmp3\n            ELSE \n                DO k=3,n-1,1\n                    result=tmp0+tmp1+tmp2+tmp3\n                    tmp0=tmp1\n                    tmp1=tmp2\n                    tmp2=tmp3\n                    tmp3=result\n                END DO\n            END IF\n\n        END FUNCTION fib4\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.08973264694213867}
{"task_id": "test/47", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: arr\n        INTEGER :: len, N, count,M,tmp\n        REAL :: result\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=numbers(N)\n        END DO\n\n        DO WHILE(len > 1)\n            DO M=2,len,1\n                IF(arr(M-1)>arr(M)) THEN\n                    tmp=arr(M)\n                    arr(M)=arr(M-1)\n                    arr(M-1)=tmp\n                END IF\n            END DO\n            len=len-1\n        END DO\n        len=SIZE(numbers)\n        IF(MOD(len,2)==1) THEN\n            result=REAL(arr(len/2+1))\n        ELSE\n            result=(REAL(arr(len/2)+arr(len/2+1)))/2\n        END IF\n\n        END FUNCTION remove_duplicates\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.08481717109680176}
{"task_id": "test/49", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION modp(n, p) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n, p\n            INTEGER :: result, i\n            result=1\n            DO i=1,n,1\n                result=MOD(result*2,p)\n            END Do\n           \n            END FUNCTION modp\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.08606743812561035}
{"task_id": "test/52", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION below_threshold(numbers, t) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, INTENT(IN) :: t\n        LOGICAL :: result\n        INTEGER :: len, N\n\n        len = SIZE(numbers)\n        result = .TRUE.\n        \n        DO N=1,len,1\n            IF(numbers(N)>=t) THEN\n                result=.FALSE.\n            END IF\n        END DO\n        END FUNCTION below_threshold\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.10341024398803711}
{"task_id": "test/53", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION add(x, y) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: x,y\n        INTEGER :: result\n        result=x+y\n        END FUNCTION add\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.08920454978942871}
{"task_id": "test/55", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION fib(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            INTEGER :: k, tmp1, tmp2\n            tmp1 = 0\n            tmp2 = 1\n            result = tmp2\n            k = 1\n            DO WHILE(k /= n)\n                result = tmp1+tmp2\n                tmp1 = tmp2\n                tmp2 = result\n                k=k+1\n\n            END DO\n\n            END FUNCTION fib\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.08782219886779785}
{"task_id": "test/57", "completion": "MODULE test_module\n    CONTAINS \n        FUNCTION monotonic(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        LOGICAL :: result,before,now\n        INTEGER :: len, N\n        \n        len = SIZE(numbers)\n        result=.TRUE.\n        IF(len>2) THEN\n            before=(numbers(1)<numbers(2))\n        END IF\n\n        DO N=3,len,1\n            now=numbers(N)>numbers(N-1)\n            IF(.NOT. (now .EQV. before)) THEN\n                result=.FALSE.\n                EXIT\n            END IF\n            before=now\n        END DO\n        END FUNCTION monotonic\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.08911871910095215}
{"task_id": "test/58", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION common(l1, l2) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: l1, l2\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result, arr1, arr2, arr3\n        INTEGER :: len1, len2, N, count,M,tmp\n        len1=SIZE(l1)\n        len2=SIZE(l2)\n        ALLOCATE(arr1(len1))\n        ALLOCATE(arr2(len2))\n        ALLOCATE(arr3(MIN(len1,len2)))\n        count=0\n        DO N=1,len1,1\n            arr1(N)=l1(N)\n        END DO\n        DO N=1,len2,1\n            arr2(N)=l2(N)\n        END DO\n        DO WHILE(len1 > 1)\n            DO M=2,len1,1\n                IF(arr1(M-1)>arr1(M)) THEN\n                    tmp=arr1(M)\n                    arr1(M)=arr1(M-1)\n                    arr1(M-1)=tmp\n                END IF\n            END DO\n            len1=len1-1\n        END DO\n        DO WHILE(len2 > 1)\n            DO M=2,len2,1\n                IF(arr2(M-1)>arr2(M)) THEN\n                    tmp=arr2(M)\n                    arr2(M)=arr2(M-1)\n                    arr2(M-1)=tmp\n                END IF\n            END DO\n            len2=len2-1\n        END DO\n        len1=SIZE(l1)\n        len2=SIZE(l2)\n        N=1\n        M=1\n        count=0\n        DO N=1,len1,1\n            IF(N==1 .OR. (N>1 .AND. arr1(N)/=arr1(N-1))) THEN\n                DO M=1,len2,1\n                    IF(arr2(M)==arr1(N)) THEN\n                        count=count+1\n                        arr3(count)=arr1(N)\n                        EXIT\n                    END IF\n                END DO\n            END IF\n        END DO\n        ALLOCATE(result(count))\n        DO WHILE(count/=0)\n            result(count) = arr3(count)\n            count=count-1\n        END DO\n        END FUNCTION common\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.10187768936157227}
{"task_id": "test/59", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION is_prime(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        LOGICAL :: result\n        INTEGER :: k\n        result=.TRUE.\n        IF(n<2) THEN\n            result=.False.\n        ELSE IF(n==2) THEN\n            result = .TRUE.\n        ELSE\n            DO k=2,n/2+1,1\n                IF(MOD(n,k)==0) THEN\n                    result=.False.\n                    EXIT\n                END IF\n            END DO\n        END IF\n        END FUNCTION is_prime\n\n        FUNCTION largest_prime_factor(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            result = n/2+1\n            \n            DO WHILE(result>1)\n                IF(MOD(n,result)==0) THEN\n                    IF(is_prime(result)) THEN\n                        EXIT\n                    END IF    \n                END IF\n                result = result -1\n            END DO\n\n            END FUNCTION largest_prime_factor\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09524679183959961}
{"task_id": "test/60", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION sum_to_n(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n\n            result = (1+n)*n/2\n           \n            END FUNCTION sum_to_n\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09747481346130371}
{"task_id": "test/62", "completion": "MODULE test_module\n    CONTAINS\n        FUNCTION derivative(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n        len=SIZE(numbers)\n\n        IF(len==1) THEN\n            ALLOCATE(result(len))\n            result(1)=0\n        ELSE\n            ALLOCATE(result(len-1))\n            DO N=2,len,1\n                result(N-1)=numbers(n)*(N-1)\n            END DO\n        END IF\n\n        END FUNCTION derivative\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09958028793334961}
{"task_id": "test/63", "completion": "MODULE test_module\n    CONTAINS\n    FUNCTION fibfib(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: result\n        INTEGER :: i\n        INTEGER, DIMENSION(n) :: fibfib_array\n        IF (n == 0) THEN\n            result = 0\n        ELSE IF (n == 1) THEN\n            result = 0\n        ELSE IF (n == 2) THEN\n            result = 1\n        ELSE\n            fibfib_array(1) = 0\n            fibfib_array(2) = 1\n            fibfib_array(3) = 1\n            \n            DO i = 4, n\n                fibfib_array(i) = fibfib_array(i-1) + fibfib_array(i-2) + fibfib_array(i-3)\n            END DO\n            \n            result = fibfib_array(n)\n        END IF\n        \n    END FUNCTION fibfib\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09383201599121094}
{"task_id": "test/68", "completion": "MODULE test_module\n    CONTAINS\n    FUNCTION pluck(arr) RESULT(output)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, DIMENSION(2) :: output\n        INTEGER :: i, smallest_value, smallest_index, flag\n        flag=0\n        output = [0, 0]\n        IF (SIZE(arr) > 0) THEN\n            smallest_value = MAXVAL(arr) + 1\n            smallest_index = 0\n            DO i = 1, SIZE(arr)\n                IF (MOD(arr(i), 2) == 0 .AND. arr(i) < smallest_value) THEN\n                    flag = 1\n                    smallest_value = arr(i)\n                    smallest_index = i\n                END IF\n            END DO\n            IF (smallest_index > 0) THEN\n                output(1) = smallest_value\n                output(2) = smallest_index-1\n            END IF\n            IF (flag == 0) THEN\n                output(1) = -1\n                output(2) = -1\n            END IF\n        END IF\n    \n    END FUNCTION pluck\n    \nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.09938335418701172}
{"task_id": "test/69", "completion": "MODULE test_module\n    CONTAINS\n    FUNCTION search(lst) RESULT(output)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: lst\n        INTEGER :: output, i, j, count\n        output = -1\n        DO i = 1, SIZE(lst)\n            count = 0\n            DO j = 1, SIZE(lst)\n                IF (lst(j) == lst(i)) THEN\n                    count = count + 1\n                END IF\n            END DO\n            IF (count >= lst(i) .AND. lst(i) > 0) THEN\n                output = MAX(output, lst(i))\n            END IF\n        END DO\n    END FUNCTION search\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.1004495620727539}
{"task_id": "test/70", "completion": "MODULE test_module\n    CONTAINS\n    FUNCTION strange_sort_list(lst) RESULT(output)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: lst\n        INTEGER, DIMENSION(:), ALLOCATABLE :: output\n        INTEGER :: i, j, min_idx, max_idx, min_val, max_val, tmp1, tmp2\n\n        ALLOCATE(output(SIZE(lst)))\n        DO i=1,SIZE(lst),1\n            output(i) = lst(i)\n        END DO\n\n        DO i = 1, SIZE(lst), 2\n            min_idx = i\n            min_val = output(i)\n            max_idx = i\n            max_val = output(i)\n\n            IF(i+1<=SIZE(lst)) THEN\n                IF(output(i+1) < output(i)) THEN\n                    min_idx=i+1\n                    min_val=output(i+1)\n                else\n                    max_idx=i+1\n                    max_val=output(i+1)\n                END IF\n            END IF\n\n            DO j = i+2, SIZE(lst), 1\n                IF (output(j) < min_val) THEN\n                    min_idx = j\n                    min_val = output(j)\n                END IF\n                IF (output(j) > max_val) THEN\n                    max_idx = j\n                    max_val = output(j)\n                END IF\n            END DO\n\n            tmp1 = output(i)\n\n            IF (i+1 <= SIZE(lst)) THEN\n                tmp2 = output(i+1)\n            END IF\n            output(i) = min_val\n            output(min_idx) = tmp1\n            IF (i+1 <= SIZE(lst)) THEN\n                output(i+1) = max_val\n                output(max_idx) = tmp2\n            END IF\n        END DO\n\n    END FUNCTION strange_sort_list\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.0937950611114502}
{"task_id": "test/71", "completion": "MODULE test_module\n    IMPLICIT NONE\n    CONTAINS \n    FUNCTION triangle_area(a, b, c) RESULT(area)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: a, b, c\n        REAL :: s, area\n        IF (a + b > c .AND. a + c > b .AND. b + c > a) THEN\n            s = (a + b + c) / 2.0\n            area = SQRT(s * (s - a) * (s - b) * (s - c))\n        ELSE\n            area = -1.0\n        END IF  \n    END FUNCTION triangle_area\n    \nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.12341833114624023}
{"task_id": "test/72", "completion": "MODULE test_module\n    CONTAINS\n    FUNCTION will_it_fly(q, w) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: q\n        INTEGER, INTENT(IN) :: w\n        INTEGER :: sum, i\n        LOGICAL :: result\n\n        sum = 0\n        result = .FALSE.\n        DO i = 1, SIZE(q)\n            IF (q(i) /= q(SIZE(q)-i+1)) THEN\n                RETURN\n            END IF\n        END DO\n        DO i = 1, SIZE(q)\n            sum = sum + q(i)\n        END DO\n        IF (sum <= w) THEN\n            result = .TRUE.\n        END IF\n\n    END FUNCTION will_it_fly\n\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.12155818939208984}
{"task_id": "test/73", "completion": "MODULE test_module\n CONTAINS\n FUNCTION smallest_change(inp) RESULT(count)\n IMPLICIT NONE\n INTEGER, DIMENSION(:), INTENT(IN) :: inp\n INTEGER, DIMENSION(:), ALLOCATABLE :: arr\n INTEGER :: count, i\n ALLOCATE(arr(SIZE(inp)))\n count = 0\n DO i=1,SIZE(arr),1\n arr(i)=inp(i)\n END DO\n DO i = 1, SIZE(arr)/2, 1\n IF (arr(i) /= arr(SIZE(arr)-i+1)) THEN\n IF (arr(i) < arr(SIZE(arr)-i+1)) THEN\n arr(i) = arr(SIZE(arr)-i+1)\n ELSE\n arr(SIZE(arr)-i+1) = arr(i)\n END IF\n count = count + 1\n END IF\n END DO\n END FUNCTION smallest_change\nEND MODULE test_module\n", "result": "passed", "passed": true, "time": 0.11734390258789062}
{"task_id": "test/75", "completion": "MODULE test_module\n    CONTAINS \n    function is_multiply_prime(a) result(found)\n        implicit none\n        INTEGER, INTENT(IN) :: a\n        LOGICAL :: found\n        INTEGER :: i, j, k\n        \n        found = .false.\n        DO i = 2, 100\n            IF (.not. is_prime(i)) cycle\n            DO j = 2, 100\n                IF (.not. is_prime(j)) cycle\n                DO k = 2, 100\n                    IF (.not. is_prime(k)) cycle\n                    IF (i*j*k == a) then\n                        found = .true.\n                        return\n                    END IF\n                END DO\n            END DO\n        END DO\n    END FUNCTION is_multiply_prime\n\n    FUNCTION is_prime(n) RESULT(is_prime_num)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: i\n            LOGICAL :: is_prime_num\n    \n            is_prime_num = .TRUE.\n    \n            DO i = 2, n-1\n                IF (MOD(n, i) == 0) THEN\n                    is_prime_num = .FALSE.\n                    EXIT\n                END IF\n            END DO\n    END FUNCTION is_prime\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.12030363082885742}
{"task_id": "test/76", "completion": "MODULE test_module\n    CONTAINS \n    FUNCTION is_simple_power(x, n) RESULT(is_simple)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: x, n\n        INTEGER :: power\n        LOGICAl :: is_simple\n        power = 0\n        is_simple = .FALSE.\n    \n        DO WHILE (n**power <= x)\n            IF (n**power == x) THEN\n                is_simple = .TRUE.\n                EXIT\n            END IF\n            power = power + 1\n        END DO\n    END FUNCTION is_simple_power\n    \nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09444546699523926}
{"task_id": "test/77", "completion": "MODULE test_module\n    CONTAINS \n    function iscube(a) result(result)\n      implicit none\n      integer, intent(in) :: a\n      logical :: result\n      integer :: abs_a\n      integer i\n  \n      abs_a = abs(a)\n      result=.false.\n      if(a==0)then\n        result=.true.\n        RETURN\n      end if\n      do i=1,abs_a\n        if(i*i*i==abs_a)then\n          result=.true.\n        end if\n        if(i*i*i>abs_a) then\n          RETURN\n        end if\n      end do\n      \n  end function iscube\nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.08939576148986816}
{"task_id": "test/78", "completion": "MODULE test_module\n    CONTAINS \n    function hex_key(num) result(count)\n        IMPLICIT NONE\n    CHARACTER(LEN=*), INTENT(IN) :: num\n    INTEGER :: i, count\n\n    count = 0\n    DO i = 1, LEN_TRIM(num)\n        SELECT CASE (num(i:i))\n            CASE ('2', '3', '5', '7', 'B', 'D')\n                count = count + 1\n        END SELECT\n    END DO\n    end function hex_key\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09223365783691406}
{"task_id": "test/82", "completion": "MODULE test_module\n    CONTAINS \n    FUNCTION prime_length(str) RESULT(is_prime)\n        IMPLICIT NONE\n        CHARACTER(LEN=*), INTENT(IN) :: str\n        LOGICAL :: is_prime\n        INTEGER :: length, i\n    \n        length = LEN_TRIM(str)\n        is_prime = .FALSE.\n    \n        IF (length <= 1) THEN\n            RETURN\n        END IF\n    \n        DO i = 2, INT(SQRT(REAL(length)))\n            IF (MOD(length, i) == 0) THEN\n                RETURN\n            END IF\n        END DO\n    \n        is_prime = .TRUE.\n    END FUNCTION prime_length\n    \nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09277820587158203}
{"task_id": "test/83", "completion": "MODULE test_module\n    CONTAINS \n    FUNCTION starts_one_ends(n) RESULT(count)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: count, i\n    \n        count = 0\n    \n        IF (n < 1) THEN\n            RETURN\n        END IF\n    \n        IF (n == 1) THEN\n            count = 1\n        ELSE\n            count = 18  \n            DO i = 2, n - 1\n                count = count * 10\n            END DO\n            \n        END IF\n    END FUNCTION starts_one_ends\n    \nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.10428023338317871}
{"task_id": "test/85", "completion": "MODULE test_module\n    CONTAINS \n    FUNCTION add(lst) RESULT(total)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: lst\n        INTEGER :: total\n        INTEGER :: i\n        \n        total = 0\n        do i = 2, size(lst), 2\n            if (mod(lst(i), 2) == 0) then\n                total = total + lst(i)\n            end if\n        end do\n    end function add\n    \nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.10448193550109863}
{"task_id": "test/88", "completion": "MODULE test_module\n    CONTAINS \n    function sort_array(arr) result(sorted_arr)\n        integer, dimension(:), intent(in) :: arr\n        integer, dimension(:), allocatable :: sorted_arr\n        integer :: n, sum_first_last\n    \n        n = size(arr)\n        sorted_arr = arr\n    \n        if (n > 0) then\n            sum_first_last = arr(1) + arr(n)\n            if (mod(sum_first_last, 2) == 0) then\n                call descending_sort(sorted_arr)\n            else\n                call ascending_sort(sorted_arr)\n            end if\n        end if\n    \n    contains\n    \n        subroutine descending_sort(arr)\n            integer, dimension(:), intent(inout) :: arr\n            integer :: i, j, temp\n    \n            do i = 1, size(arr) - 1\n                do j = i + 1, size(arr)\n                    if (arr(i) < arr(j)) then\n                        temp = arr(i)\n                        arr(i) = arr(j)\n                        arr(j) = temp\n                    end if\n                end do\n            end do\n        end subroutine descending_sort\n    \n        subroutine ascending_sort(arr)\n            integer, dimension(:), intent(inout) :: arr\n            integer :: i, j, temp\n    \n            do i = 1, size(arr) - 1\n                do j = i + 1, size(arr)\n                    if (arr(i) > arr(j)) then\n                        temp = arr(i)\n                        arr(i) = arr(j)\n                        arr(j) = temp\n                    end if\n                end do\n            end do\n        end subroutine ascending_sort\n    \n    end function sort_array\nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.10074996948242188}
{"task_id": "test/94", "completion": "MODULE test_module\n    CONTAINS \n    function skjkasdkd(lst) result(sum)\n        implicit none\n        integer, intent(in) :: lst(:)\n        integer :: i, j, num, sum, max_prime\n        logical :: is_prime\n        \n        max_prime = -1  ! Initialize the largest prime value to a negative number\n        \n        do i = 1, size(lst)\n          num = lst(i)\n          \n          ! Check if num is a prime number\n          is_prime = .true.\n          if (num <= 1) then\n            is_prime = .false.\n          else\n            do j = 2, num - 1\n              if (mod(num, j) == 0) then\n                is_prime = .false.\n                exit\n              endif\n            enddo\n          endif\n          \n          ! Update the largest prime value if necessary\n          if (is_prime .and. num > max_prime) then\n            max_prime = num\n          endif\n        enddo\n        \n        sum = 0\n        \n        ! Calculate the sum of digits of the largest prime value\n        if (max_prime > 0) then\n          do while (max_prime > 0)\n            sum = sum + mod(max_prime, 10)\n            max_prime = max_prime / 10\n          enddo\n        endif\n        \n      end function skjkasdkd\n    \nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.10099458694458008}
{"task_id": "test/96", "completion": "MODULE test_module\n    CONTAINS \n    function count_up_to(n) result(primes)\n        integer, intent(in) :: n\n        integer, allocatable :: primes(:)\n        integer :: num, count\n      \n        count = 0\n        do num = 2, n - 1\n          if (is_prime(num)) then\n            count = count + 1\n          end if\n        end do\n      \n        allocate(primes(count))\n        count = 1\n        do num = 2, n - 1\n          if (is_prime(num)) then\n            primes(count) = num\n            count = count + 1\n          end if\n        end do\n    end function count_up_to\n    \n    function is_prime(num) result(isprime)\n          integer, intent(in) :: num\n          integer :: i\n          LOGICAL :: isprime\n      \n          if (num < 2) then\n            isprime = .false.\n            return\n          end if\n      \n          do i = 2, int(sqrt(real(num)))\n            if (mod(num, i) == 0) then\n              isprime = .false.\n              return\n            end if\n          end do\n      \n          isprime = .true.\n        end function is_prime\n      \n      \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.0907588005065918}
{"task_id": "test/97", "completion": "MODULE test_module\n    CONTAINS \n    function multiply(num1, num2) result(result)\n        integer, intent(in) :: num1, num2\n        integer :: result\n    \n        result = mod(abs(num1), 10) * mod(abs(num2), 10)\n    end function multiply\n    \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.09473037719726562}
{"task_id": "test/100", "completion": "MODULE test_module\n    CONTAINS \n    FUNCTION make_a_pile(n) result(pile)\n        INTEGER, intent(in) :: n\n        INTEGER, DIMENSION(:), ALLOCATABLE :: pile\n        INTEGER :: i, num_stones\n    \n        allocate(pile(n))\n    \n        num_stones = n\n        do i = 1, n\n            pile(i) = n+2*(i-1)\n        end do\n    end FUNCTION make_a_pile\n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.09913921356201172}
{"task_id": "test/102", "completion": "MODULE test_module\n    CONTAINS \n    function choose_num(x, y) result(max_even)\n        integer, intent(in) :: x, y\n        integer :: max_even, i\n    \n        max_even = -1\n        do i = y, x, -1\n            if (mod(i, 2) == 0) then\n                max_even = i\n                exit\n            end if\n        end do\n    end function choose_num\n    \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.09005403518676758}
{"task_id": "test/106", "completion": "MODULE test_module\n    CONTAINS \n    function f(n) result(res)\n        integer, intent(in) :: n\n        integer, dimension(n) :: res\n        integer :: i, j, factorial, sum\n      \n        do i = 1, n\n          if (mod(i, 2) == 0) then\n            factorial = 1\n            do j = 1, i\n              factorial = factorial * j\n            end do\n            res(i) = factorial\n          else\n            sum = 0\n            do j = 1, i\n              sum = sum + j\n            end do\n            res(i) = sum\n          end if\n        end do\n      \n      end function f\n      \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.11026239395141602}
{"task_id": "test/107", "completion": "MODULE test_module\n    CONTAINS \n    function even_odd_palindrome(n) result(res)\n        integer, intent(in) :: n\n        integer :: i, count_even, count_odd\n        INTEGER, DIMENSION(2) :: res\n        logical :: is_palindrome\n      \n        count_even = 0\n        count_odd = 0\n      \n        do i = 1, n\n          is_palindrome = check_palindrome(i)\n          if (is_palindrome) then\n            if (mod(i, 2) == 0) then\n              count_even = count_even + 1\n            else\n              count_odd = count_odd + 1\n            end if\n          end if\n        end do\n      \n        res(1) = count_even\n        res(2) = count_odd\n      end function even_odd_palindrome\n      \n      function check_palindrome(num) result(check)\n        integer, intent(in) :: num\n        integer :: original, reversed, remainder, tmp\n        logical :: check\n      \n        original = num\n        tmp = num\n        reversed = 0\n      \n        do while (tmp > 0)\n          remainder = mod(tmp, 10)\n          reversed = reversed * 10 + remainder\n          tmp = tmp / 10\n        end do\n      \n        if (original == reversed) then\n          check = .true.\n        else\n          check = .false.\n        end if\n      end function check_palindrome\n      \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.10645031929016113}
{"task_id": "test/108", "completion": "MODULE test_module\n    CONTAINS \n    function count_nums(arr) result(count)\n        integer, intent(in) :: arr(:)\n        integer :: count, i, num, digit_sum\n      \n        count = 0\n        do i = 1, size(arr)\n          num = ABS(arr(i))\n          digit_sum = 0\n          do while (num /= 0)\n            if (num >= 10) then\n              digit_sum = digit_sum + mod(num, 10)\n            else\n              digit_sum = digit_sum + mod(num, 10)*(arr(i)/ABS(arr(i)))\n            end if\n            num = num / 10\n          end do\n      \n          if (digit_sum > 0) then\n            count = count + 1\n          endif\n        end do\n      \n      end function count_nums\n      \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.11117100715637207}
{"task_id": "test/109", "completion": "MODULE test_module\n    CONTAINS \n    function move_one_ball(arr) result(is_sorted)\n      implicit none\n      logical :: is_sorted\n      integer, dimension(:), intent(in) :: arr\n      integer :: i, min_value, min_index, n\n      integer, dimension(size(arr)) :: sorted_array, my_arr\n  \n      n = size(arr)\n  \n      if (n == 0) then\n          is_sorted = .true.\n          return\n      end if\n  \n      sorted_array = sort(arr)\n      my_arr = arr\n  \n      min_value = minval(arr)\n      min_index = minloc(arr, dim=1)\n  \n      my_arr = [arr(min_index:n), arr(1:min_index-1)]\n  \n      do i = 1, n\n          if (my_arr(i) /= sorted_array(i)) then\n              is_sorted = .false.\n              return\n          end if\n      end do\n  \n      is_sorted = .true.\n  end function move_one_ball\n\n  function sort(arr) result(sorted_arr)\n    implicit none\n    integer, dimension(:), intent(in) :: arr\n    integer, dimension(size(arr)) :: sorted_arr\n    integer :: i, j, temp\n    integer :: n\n\n\n    sorted_arr = arr\n\n\n    n = size(sorted_arr)\n\n\n    do i = 1, n-1\n        do j = 1, n-i\n            if (sorted_arr(j) > sorted_arr(j+1)) then\n                temp = sorted_arr(j)\n                sorted_arr(j) = sorted_arr(j+1)\n                sorted_arr(j+1) = temp\n            end if\n        end do\n    end do\nend function sort\n      \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.10360836982727051}
{"task_id": "test/114", "completion": "MODULE test_module\n    CONTAINS \n    function minSubArraySum(nums) result(min_sum)\n      implicit none\n      integer, dimension(:), intent(in) :: nums\n      integer :: min_sum, max_sum, s, num\n      integer :: i, n\n  \n      n = size(nums)\n  \n      max_sum = 0\n      s = 0\n  \n      do i = 1, n\n          num = -nums(i)\n          s = s + num\n  \n          if (s < 0) then\n              s = 0\n          end if\n  \n          max_sum = max(s, max_sum)\n      end do\n  \n      if (max_sum == 0) then\n          max_sum = maxval(-nums)\n      end if\n  \n      min_sum = -max_sum\n  end function minSubArraySum\n      \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.09279513359069824}
{"task_id": "test/120", "completion": "MODULE test_module\n    CONTAINS \n    function maximum(arr, k) result(ans)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: k\n        integer, dimension(:), allocatable :: sorted_arr, ans\n        integer :: n\n    \n        if (k == 0) then\n            allocate(ans(0))\n            return\n        end if\n    \n        n = size(arr)\n    \n        allocate(sorted_arr(n))\n        sorted_arr = arr\n        call quicksort(sorted_arr, 1, n)\n    \n        allocate(ans(k))\n        ans = sorted_arr(n-k+1:n)\n    \n    contains\n    \n        RECURSIVE subroutine quicksort(arr, low, high)\n            implicit none\n            integer, dimension(:), intent(inout) :: arr\n            integer, intent(in) :: low, high\n            integer :: i, j, pivot, temp\n    \n            if (low < high) then\n                pivot = arr(high)\n                i = low - 1\n    \n                do j = low, high-1\n                    if (arr(j) <= pivot) then\n                        i = i + 1\n                        temp = arr(i)\n                        arr(i) = arr(j)\n                        arr(j) = temp\n                    end if\n                end do\n    \n                temp = arr(i+1)\n                arr(i+1) = arr(high)\n                arr(high) = temp\n    \n                call quicksort(arr, low, i)\n                call quicksort(arr, i+2, high)\n            end if\n        end subroutine quicksort\n    \n    end function maximum\n    \n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.09258460998535156}
{"task_id": "test/121", "completion": "MODULE test_module\n    CONTAINS \n    function sum_odd_elements(arr) result(sum)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: sum, i\n    \n        sum = 0\n        do i = 1, size(arr), 2\n            if (mod(arr(i), 2) /= 0) then\n                sum = sum + arr(i)\n            end if\n        end do\n    \n    end function sum_odd_elements\n    \n    \n    \nEND MODULE test_module", "result": "passed", "passed": true, "time": 0.09892988204956055}
{"task_id": "test/122", "completion": "MODULE test_module\n    CONTAINS \n    function add_elements(arr, k) result(sum)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: k\n        integer :: sum, i, count\n    \n        sum = 0\n        count = 0\n        do i = 1, k\n            if (abs(arr(i)) < 100) then\n                sum = sum + arr(i)\n                count = count + 1\n            end if\n        end do\n    \n    end function add_elements\n    \nEND MODULE test_module  ", "result": "passed", "passed": true, "time": 0.09529352188110352}
{"task_id": "test/123", "completion": "MODULE test_module\n    CONTAINS \n    function get_odd_collatz(n) result(odd_list)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: odd_list\n        integer :: num, count\n    \n        allocate(odd_list(n))\n        count = 0\n        num = n\n        do while (num > 1)\n            if (mod(num, 2) == 1) then\n                count = count + 1\n                odd_list(count) = num\n            end if\n            if (mod(num, 2) == 0) then\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end if\n        end do\n        count = count + 1\n        odd_list(count) = 1\n        odd_list = odd_list(1:count)\n        call sort_odd_list(odd_list)\n    \n    contains\n    \n        subroutine sort_odd_list(list)\n            implicit none\n            integer, dimension(:), intent(inout) :: list\n            integer :: i, j, temp\n    \n            do i = 1, size(list)-1\n                do j = i+1, size(list)\n                    if (list(i) > list(j)) then\n                        temp = list(i)\n                        list(i) = list(j)\n                        list(j) = temp\n                    end if\n                end do\n            end do\n    \n        end subroutine sort_odd_list\n    \n    end function get_odd_collatz\n    \n       \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.1296226978302002}
{"task_id": "test/126", "completion": "MODULE test_module\n    CONTAINS \n    function is_sorted(lst) result(sorted)\n        implicit none\n        integer, dimension(:), intent(in) :: lst\n        logical :: sorted\n        integer, dimension(:), allocatable :: count_digit\n        integer :: i, n\n    \n        n = size(lst)\n    \n        allocate(count_digit(n))\n        count_digit = 0\n    \n        do i = 1, n\n            count_digit(lst(i)) = count_digit(lst(i)) + 1\n        end do\n    \n        if (any(count_digit > 2)) then\n            sorted = .false.\n            return\n        end if\n    \n        sorted = all(lst(1:n-1) <= lst(2:n))\n    end function is_sorted\n    \n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.1268177032470703}
{"task_id": "test/128", "completion": "MODULE test_module\n    CONTAINS \n    function prod_signs(arr) result(result_sum)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: i\n        integer :: product_sign, sum_magnitudes, result_sum\n    \n        if (size(arr) == 0) then\n            result_sum = 0\n            return\n        end if\n    \n        product_sign = 1\n        sum_magnitudes = 0\n    \n        do i = 1, size(arr)\n            if (arr(i) > 0) then\n                product_sign = product_sign * 1\n            else if (arr(i) < 0) then\n                product_sign = product_sign * (-1)\n            else\n                product_sign = product_sign * 0\n            end if\n    \n            sum_magnitudes = sum_magnitudes + abs(arr(i))\n        end do\n    \n        result_sum = sum_magnitudes * product_sign\n    \n    end function prod_signs\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.1191716194152832}
{"task_id": "test/130", "completion": "MODULE test_module\n    CONTAINS \n    function tri(n) result(my_tri)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: my_tri\n        integer :: i\n    \n        if (n == 0) then\n            allocate(my_tri(1))\n            my_tri(1) = 1\n            return\n        end if\n    \n        allocate(my_tri(n + 1))\n        my_tri(1) = 1\n        my_tri(2) = 3\n    \n        do i = 3, n+1\n            if (mod(i-1, 2) == 0) then\n                my_tri(i) = (i-1)/ 2 + 1\n            else\n                my_tri(i) = my_tri(i - 1) + my_tri(i - 2) + (i-1 + 3) / 2\n            end if\n        end do\n    \n    end function tri\nEND MODULE test_module \n", "result": "passed", "passed": true, "time": 0.12269186973571777}
{"task_id": "test/131", "completion": "MODULE test_module\n    CONTAINS \n    function digits1(m) result(product)\n        implicit none\n        integer, intent(in) :: m\n        integer :: product, odd_count, int_digit, n\n        character(len=1) :: digit\n    \n        product = 1\n        odd_count = 0\n        n = m\n    \n        do while (n /= 0)\n            digit = char(mod(n, 10) + 48)\n            int_digit = ichar(digit) - 48\n    \n            if (mod(int_digit, 2) == 1) then\n                product = product * int_digit\n                odd_count = odd_count + 1\n            end if\n    \n            n = n / 10\n        end do\n    \n        if (odd_count == 0) then\n            product = 0\n        end if\n    end function digits1\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.10081076622009277}
{"task_id": "test/133", "completion": "MODULE test_module\n    CONTAINS \n    function sum_squares(lst) result(total)\n        implicit none\n        real, dimension(:), intent(in) :: lst\n        integer :: i, total\n    \n        total = 0\n    \n        do i = 1, size(lst)\n            total = total + ceiling(lst(i))**2\n        end do\n    \n    end function sum_squares\n    \nEND MODULE test_module \n", "result": "passed", "passed": true, "time": 0.11139559745788574}
{"task_id": "test/135", "completion": "MODULE test_module\n    CONTAINS \n    function can_arrange(arr) result(ind)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: ind, i\n    \n        ind = -1\n        i = 2\n    \n        do while (i <= size(arr))\n            if (arr(i) < arr(i-1)) then\n                ind = i-1\n            end if\n            i = i + 1\n        end do\n    \n    end function can_arrange\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.10211801528930664}
{"task_id": "test/138", "completion": "MODULE test_module\n    CONTAINS \n    function is_equal_to_sum_even(n) result(is_equal)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i, j, k, l\n        logical :: is_equal\n    \n        is_equal = .false.\n        do i = 2, n-6, 2\n            do j = i, n-i-4, 2\n                do k = j, n-i-j-2, 2\n                    l = n - i - j - k\n                    if (mod(l, 2) == 0 .and. l > 0) then\n                        is_equal = .true.\n                        return\n                    end if\n                end do\n            end do\n        end do\n    \n    end function is_equal_to_sum_even\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.10576915740966797}
{"task_id": "test/139", "completion": "MODULE test_module\n    CONTAINS \n    function brazilian_factorial(n) result(factorial)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i, j, factorial\n    \n        factorial = 1\n        do i = n, 1, -1\n            do j = i, 1, -1\n                factorial = factorial * j\n            end do\n        end do\n    \n    end function brazilian_factorial\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.11910653114318848}
{"task_id": "test/142", "completion": "MODULE test_module\n    CONTAINS \n    function sum_squares(inp) result(sum)\n        implicit none\n        integer, intent(in) :: inp(:)\n        integer, dimension(:), allocatable :: lst\n        integer :: i, n, sum\n    \n        n = size(inp)\n        allocate(lst(n))\n        sum = 0\n    \n        do i = 1, n\n            lst(i) = inp(i)\n            if (mod(i-1, 3) == 0) then\n                lst(i) = lst(i) ** 2\n            elseif (mod(i-1, 4) == 0 .and. mod(i-1, 3) /= 0) then\n                lst(i) = lst(i) ** 3\n            end if\n    \n            sum = sum + lst(i)\n        end do\n    \n    end function sum_squares    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.11131072044372559}
{"task_id": "test/146", "completion": "MODULE test_module\n    CONTAINS \n    function specialFilter(arr) result(count)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: count, i, num, first_digit, last_digit\n    \n        count = 0\n    \n        do i = 1, size(arr)\n            num = abs(arr(i))\n            first_digit = abs(mod(num, 10))\n            last_digit = abs(num / 10 ** int(log10(real(num))) )\n    \n            if (arr(i) > 10 .and. odd_digit(first_digit) .and. odd_digit(last_digit)) then\n                count = count + 1\n            end if\n        end do\n    \n    contains\n    \n        function odd_digit(digit) result(is_odd)\n            implicit none\n            integer, intent(in) :: digit\n            logical :: is_odd\n    \n            is_odd = digit == 1 .or. digit == 3 .or. digit == 5 .or. digit == 7 .or. digit == 9\n        end function odd_digit\n    \n    end function specialFilter    \nEND MODULE test_module   \n", "result": "passed", "passed": true, "time": 0.1301274299621582}
{"task_id": "test/147", "completion": "MODULE test_module\n    CONTAINS \n    function get_max_triples(n) result(count)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(n) :: a\n        integer :: count, i, j, k\n    \n        count = 0\n    \n        do i = 1, n\n            a(i) = i * i - i + 1\n        end do\n    \n        do i = 1, n - 2\n            do j = i + 1, n - 1\n                do k = j + 1, n\n                    if (mod(a(i) + a(j) + a(k), 3) == 0) then\n                        count = count + 1\n                    end if\n                end do\n            end do\n        end do\n    \n    end function get_max_triples\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.11923408508300781}
{"task_id": "test/150", "completion": "MODULE test_module\n    CONTAINS \n    function x_or_y(n, x, y) result(result_value)\n        implicit none\n        integer, intent(in) :: n, x, y\n        integer :: result_value, i, is_prime\n    \n        is_prime = 1\n    \n        if (n <= 1) then\n            is_prime = 0\n        else\n            do i = 2, n - 1\n                if (mod(n, i) == 0) then\n                    is_prime = 0\n                    exit\n                end if\n            end do\n        end if\n    \n        if (is_prime == 1) then\n            result_value = x\n        else\n            result_value = y\n        end if\n    \n    end function x_or_y\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.09292435646057129}
{"task_id": "test/152", "completion": "MODULE test_module\n    CONTAINS \n    function compare(scores, guesses) result(diff)\n        implicit none\n        integer, dimension(:), intent(in) :: scores, guesses\n        integer, dimension(:), allocatable :: diff\n        integer :: i, n\n    \n        n = size(scores)\n        allocate(diff(n))\n    \n        do i = 1, n\n            if (scores(i) == guesses(i)) then\n                diff(i) = 0\n            else\n                diff(i) = abs(scores(i) - guesses(i))\n            end if\n        end do\n    \n    end function compare\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.09550356864929199}
{"task_id": "test/155", "completion": "MODULE test_module\n    CONTAINS \n    function even_odd_count(m) result(count)\n        implicit none\n        integer, intent(in) :: m\n        integer :: count(2), digit, n\n    \n        count = 0\n        n=m\n        if(n==0) then\n            count(1)=1\n            return\n        end if\n        do while (n /= 0)\n            digit = abs(mod(n, 10))\n    \n            if (mod(digit, 2) == 0) then\n                count(1) = count(1) + 1  ! even count\n            else\n                count(2) = count(2) + 1  ! odd count\n            end if\n    \n            n = n / 10\n        end do\n    \n    end function even_odd_count\nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.09553050994873047}
{"task_id": "test/157", "completion": "MODULE test_module\n    CONTAINS \n    function right_angle_triangle(a, b, c) result(is_right_angle)\n        implicit none\n        integer, intent(in) :: a, b, c\n        logical :: is_right_angle\n    \n        is_right_angle = a*a + b*b == c*c .or. a*a + c*c == b*b .or. b*b + c*c == a*a\n    \n    end function right_angle_triangle\n    \nEND MODULE test_module  \n", "result": "passed", "passed": true, "time": 0.09684205055236816}
{"task_id": "test/159", "completion": "MODULE test_module\n    CONTAINS \n    function eat(number, need, remaining) result(result_arr)\n        implicit none\n        integer, intent(in) :: number, need, remaining\n        integer, dimension(2) :: result_arr\n    \n        if (need <= remaining) then\n            result_arr(1) = number + need\n            result_arr(2) = remaining - need\n        else\n            result_arr(1) = number + remaining\n            result_arr(2) = 0\n        end if\n    \n    end function eat\nEND MODULE test_module  \n\n", "result": "passed", "passed": true, "time": 0.09273624420166016}
{"task_id": "test/163", "completion": "MODULE test_module\n    CONTAINS \n    function generate_integers(a, b) result(integers)\n        implicit none\n        integer, intent(in) :: a, b\n        integer, dimension(:), allocatable :: integers\n        integer :: lower, upper, i, count\n    \n        lower = max(2, min(a, b))\n        upper = min(8, max(a, b))\n    \n        count = 0\n        do i = lower, upper\n            if (mod(i, 2) == 0) then\n                count = count + 1\n            end if\n        end do\n    \n        allocate(integers(count))\n        count = 0\n        do i = lower, upper\n            if (mod(i, 2) == 0) then\n                count = count + 1\n                integers(count) = i\n            end if\n        end do\n    \n    end function generate_integers\nEND MODULE test_module  \n\n", "result": "passed", "passed": true, "time": 0.0980081558227539}
