{"task_id": "test/0", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION has_close_elements(numbers, threshold) RESULT(result)\n!your code\nEND FUNCTION has_close_elements\nEND MODULE test_module \"\n functionality:\nCheck if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    F\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    T\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION has_close_elements(numbers, threshold) RESULT(result)\n        IMPLICIT NONE\n        REAL, DIMENSION(:), INTENT(IN) :: numbers\n        REAL,INTENT(IN) :: threshold \n        INTEGER :: size0, N, M\n        LOGICAL :: result\n        result = .FALSE.\n        size0 = SIZE(numbers)\n\n        DO N = 1, SIZE(numbers),1\n            DO M = N+1,size0,1\n                IF(ABS(numbers(M)-numbers(N))<threshold) THEN\n                    result = .TRUE.\n                    EXIT\n                    END IF\n                END DO\n            END DO\n        END FUNCTION has_close_elements\nEND MODULE test_module\n", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1.0, 2.0, 3.0], 0.5, .false.)\n    call test([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3, .true.)\n    call test([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3, .true.)\n    call test([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05, .false.)\n    call test([1.0, 2.0, 5.9, 4.0, 5.0], 0.95, .True.)\n    call test([1.0, 2.0, 5.9, 4.0, 5.0], 0.8, .false.)\n    call test([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1, .true.)\n    call test([1.1, 2.2, 3.1, 4.1, 5.1], 1.0, .True.)\n    call test([1.1, 2.2, 3.1, 4.1, 5.1], 0.5, .false.)\n    contains\n    subroutine test (p1, p2, st)\n        implicit none\n            REAL, DIMENSION(:), INTENT(IN) :: p1\n            REAL, INTENT(IN) :: p2\n            logical, INTENT(IN) :: st\n            logical :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = has_close_elements(p1, p2)\n            if (a .eqv. st) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, st\n            end if\n        end subroutine test\n\nEND PROGRAM main\n"}
{"task_id": "test/2", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION truncate_number(number) RESULT(result)\n!your code\nEND FUNCTION truncate_number\nEND MODULE test_module \"\n functionality:\nGiven a positive floating point number, it can be decomposed into\n     and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION truncate_number(number) RESULT(result)\n        IMPLICIT NONE\n        REAL,INTENT(IN) :: number\n        REAL :: result\n        result = number - REAL(INT(number))\n        END FUNCTION truncate_number\nEND MODULE test_module", "test":"PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3.5, 0.5)\n    call test(1.33, 0.33)\n    call test(123.456, 0.456)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            real, intent(in) :: r\n            real, intent(in) :: ra\n            real :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = truncate_number(r)\n            if (ABS(a-ra)>1e-5) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n\nEND PROGRAM main"}
{"task_id": "test/3", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION below_zero(numbers) RESULT(result)\n!your code\nEND FUNCTION below_zero\nEND MODULE test_module \"\n functionality:\nYou're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION below_zero(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER :: len, N, tmp\n        LOGICAL :: result\n        result = .FALSE.\n        tmp=0\n        len = SIZE(numbers)\n\n        DO N = 1, len,1\n            IF(tmp+numbers(N)<0) THEN\n                result = .TRUE.\n                EXIT\n            ELSE\n                tmp = tmp + numbers(N)\n            END IF\n        END DO\n    END FUNCTION below_zero\nEND MODULE test_module", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, -3, 1, 2, -3], .FALSE.)\n    call test([1, 2, -4, 5, 6], .TRUE.)\n    call test([1, -1, 2, -2, 5, -5, 4, -4], .FALSE.)\n    call test([1, -1, 2, -2, 5, -5, 4, -5], .TRUE.)\n    call test([1, -2, 2, -2, 5, -5, 4, -4], .TRUE.)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = below_zero(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/4", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION mean_absolute_deviation(numbers) RESULT(result)\n!your code\nEND FUNCTION mean_absolute_deviation\nEND MODULE test_module \"\n functionality:\nFor a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION mean_absolute_deviation(numbers) RESULT(result)\n        IMPLICIT NONE\n        REAL, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER :: len, N\n        REAL :: result, means\n        result = 0.0\n        len = SIZE(numbers)\n        means = SUM(numbers)/REAL(len)\n\n        DO N = 1, len,1\n            result=result+ABS(numbers(N)-means)\n        END DO\n        result = result/REAL(len)\n        END FUNCTION mean_absolute_deviation\nEND MODULE test_module", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1.0, 2.0, 3.0], 2.0/3.0)\n    call test([1.0, 2.0, 3.0, 4.0], 1.0)\n    call test([1.0, 2.0, 3.0, 4.0, 5.0], 6.0/5.0)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            REAL, DIMENSION(:), INTENT(IN) :: r\n            real, intent(in) :: ra\n            real :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = mean_absolute_deviation(r)\n            if (ABS(a-ra)>1e-6) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n\nEND PROGRAM main\n"}
{"task_id": "test/5", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION mean_absolute_deviation(numbers, delimeter) RESULT(result)\n!your code\nEND FUNCTION mean_absolute_deviation\nEND MODULE test_module \"\n functionality:\nInsert a number 'delimeter' between every two consecutive elements of input list `numbers'\n ", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION mean_absolute_deviation(numbers, delimeter) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, INTENT(IN) :: delimeter\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n\n        len = SIZE(numbers)\n        If(len == 1) THEN\n            ALLOCATE(result(len))\n            result(1) = numbers(1)\n        ELSE IF(len >= 2) THEN\n            ALLOCATE(result(len*2-1))\n            DO N=1,len-1,1\n                result(2*N-1)=numbers(N)\n                result(2*N)=delimeter\n            END DO\n            result(2*len-1)=numbers(len)\n        ELSE\n        END IF\n        END FUNCTION mean_absolute_deviation\nEND MODULE test_module", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n  call test([5, 6, 3, 2], 8, [5, 8, 6, 8, 3, 8, 2])\n  call test([2, 2, 2], 2, [2, 2, 2, 2, 2])\n  \n  contains\n  subroutine test (r, n, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, INTENT(IN) :: n\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = mean_absolute_deviation(r,n)\n      call judge(a, ra, result)\n      if (result .eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/8", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION sum_product(numbers) RESULT(result)\n!your code\nEND FUNCTION sum_product\nEND MODULE test_module \"\n functionality:\nFor a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n ","canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION sum_product(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(2) :: result\n        INTEGER :: len, N,tmp,sum0\n        tmp = 1\n        sum0 = SUM(numbers)\n        len = SIZE(numbers)\n        DO N = 1, len,1\n            tmp=tmp*numbers(N)\n        END DO\n        result(1)=sum0\n        result(2)=tmp\n        END FUNCTION sum_product\nEND MODULE test_module", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n  call test([1, 1, 1],[3,1])\n  call test([100, 0],[100,0])\n  call test([3, 5, 7],[3 + 5 + 7, 3 * 5 * 7])\n  call test([10],[10,10])\n  \n  contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = sum_product(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/9", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION rolling_max(numbers) RESULT(result)\n!your code\nEND FUNCTION rolling_max\nEND MODULE test_module \"\n functionality:\nFrom a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION rolling_max(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N, maxn\n        maxn = numbers(1)\n        len = SIZE(numbers)\n        ALLOCATE(result(len))\n        \n        DO N=1,len,1\n            maxn=MAX(maxn,numbers(N))\n            result(N)=maxn\n        END DO\n        END FUNCTION rolling_max\nEND MODULE test_module\n", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, 3, 4], [1, 2, 3, 4])\n    call test([4, 3, 2, 1], [4, 4, 4, 4])\n    call test([3, 2, 3, 100, 3], [3, 3, 3, 100, 100])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = rolling_max(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/13", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION greatest_common_divisor(a, b) RESULT(result)\n!your code\nEND FUNCTION greatest_common_divisor\nEND MODULE test_module \"\n functionality:\nReturn a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION greatest_common_divisor(a, b) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: a, b\n        INTEGER:: result, tmp1, tmp2\n        tmp1 = a\n        tmp2 = b\n        DO WHILE(tmp2/=0)\n            result=tmp2\n            tmp2=MOD(tmp1,tmp2)\n            tmp1=result\n        END DO\n        result=tmp1\n        END FUNCTION greatest_common_divisor\nEND MODULE test_module\n", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3,7,1)\n    call test(10,15,5)\n    call test(49,14,7)\n    call test(144,60,12)\n    contains\n  subroutine test (p1, p2 ,st)\n  implicit none\n      INTEGER, INTENT(IN) :: p1, p2, st\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = greatest_common_divisor(p1, p2)\n      if (a/=st) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, st\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/21", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION rescale_to_unit(numbers) RESULT(result)\n!your code\nEND FUNCTION rescale_to_unit\nEND MODULE test_module \"\n functionality:\nGiven list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION rescale_to_unit(numbers) RESULT(result)\n        IMPLICIT NONE\n        REAL, DIMENSION(:), INTENT(IN) :: numbers\n        REAL, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n        REAL :: maxn, minn\n        maxn = numbers(1)\n        minn = numbers(1)\n        len = SIZE(numbers)\n        ALLOCATE(result(len))\n        \n        DO N=1,len,1\n            maxn=MAX(maxn,numbers(N))\n            minn=MIN(minn,numbers(N))\n            \n        END DO\n        DO N=1,len,1\n            result(N)=(numbers(n)-minn)/(maxn-minn)\n        END DO\n        END FUNCTION rescale_to_unit\nEND MODULE test_module\n", "test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([2.0, 49.9], [0.0, 1.0])\n    call test([100.0, 49.9], [1.0, 0.0])\n    call test([1.0, 2.0, 3.0, 4.0, 5.0], [0.0, 0.25, 0.5, 0.75, 1.0])\n    call test([2.0, 1.0, 5.0, 3.0, 4.0], [0.25, 0.0, 1.0, 0.5, 0.75])\n    call test([12.0, 11.0, 15.0, 13.0, 14.0], [0.25, 0.0, 1.0, 0.5, 0.75])\n\n    contains\n  subroutine test (r, ra)\n  implicit none\n  real, DIMENSION(:), INTENT(IN) :: r\n  real, DIMENSION(:), INTENT(IN) :: ra\n  real, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = rescale_to_unit(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    real, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (ABS(arr1(i)-arr2(i))>1e-4) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/24", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION largest_divisor(n) RESULT(result)\n!your code\nEND FUNCTION largest_divisor\nEND MODULE test_module \"\n functionality:\nFor a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION largest_divisor(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: result\n        result = n/2 +1\n\n        DO WHILE(MOD(n,result)>0)\n            result = result - 1\n        END DO\n        END FUNCTION largest_divisor\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3,1)\n    call test(7,1)\n    call test(10,5)\n    call test(100,50)\n    call test(49,7)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = largest_divisor(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/25", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION factorize(n) RESULT(result)\n!your code\nEND FUNCTION factorize\nEND MODULE test_module \"\n functionality:\nReturn list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n  ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION factorize(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: i,maxn,tmp,len\n        i=2\n        len=0\n        maxn=INT(SQRT(REAL(n))+1)\n        tmp=n\n        DO WHILE(i<=maxn)\n            IF(tmp<i) THEN\n                EXIT\n            END IF\n            IF(MOD(tmp,i)==0) THEN\n                tmp=INT(tmp/i)\n                len=len+1\n            ELSE\n                i=i+1\n            END IF\n        END DO\n        IF(tmp > 1) THEN\n            len=len+1\n        END IF\n        ALLOCATE(result(len))\n        tmp=n\n        i=2\n        len=0\n        DO WHILE(i<=maxn)\n            IF(MOD(tmp,i)==0) THEN\n                tmp=INT(tmp/i)\n                result(len+1)=i\n                len=len+1\n            ELSE\n                i=i+1\n            END IF\n        END DO\n        IF(tmp > 1) THEN\n            result(len+1)=tmp;\n        END IF\n        END FUNCTION factorize\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(2, [2])\n    call test(4, [2, 2])\n    call test(8, [2, 2, 2])\n    call test(3 * 19, [3, 19])\n    call test(3 * 19 * 3 * 19, [3, 3, 19, 19])\n    call test(3 * 19 * 3 * 19* 3 * 19, [3, 3, 3, 19, 19, 19])\n    call test(3 * 19 * 19 * 19, [3, 19, 19, 19])\n    call test(3 *2*3, [2, 3, 3])\n    contains\n    subroutine test (r, ra)\n        implicit none\n        INTEGER, INTENT(IN) :: r\n        INTEGER, DIMENSION(:), INTENT(IN) :: ra\n        INTEGER, DIMENSION(:), ALLOCATABLE:: a\n            logical :: exists\n            logical :: result\n            inquire(file='result.txt', exist=exists)\n            a = factorize(r)\n            call judge(a, ra, result)\n            if (result.eqv. .false.) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n      \n        subroutine judge(arr1, arr2,result) \n          INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n          LOGICAL, intent(INOUT) :: result\n          INTEGER :: i\n          \n          result = .TRUE.\n          IF (SIZE(arr1) /= SIZE(arr2)) THEN\n              result = .FALSE.\n              RETURN\n          END IF\n          \n          DO i = 1, SIZE(arr1)\n              IF (arr1(i) /= arr2(i)) THEN\n                  result = .FALSE.\n                  RETURN\n              END IF\n          END DO\n      END subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/26", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION remove_duplicates(numbers) RESULT(result)\n!your code\nEND FUNCTION remove_duplicates\nEND MODULE test_module \"\n functionality:\nFrom a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n   ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result, arr\n        INTEGER :: len, N, count,M,tmp\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=0\n        END DO\n        DO N=1,len,1\n            IF(arr(N)==0) THEN\n                tmp=count\n                DO M=N+1,len,1\n                    IF(numbers(N)==numbers(M)) THEN\n                        arr(M)=1\n                        count=count+1\n                    END IF\n                END DO\n                IF(tmp/=count) THEN\n                    arr(N)=1\n                    count=count+1\n                END IF\n            END IF\n        END DO\n        ALLOCATE(result(len-count))\n        M=1\n        DO N=1,len,1\n            IF(arr(N)==0) THEN\n                result(M)=numbers(N)\n                M=M+1\n            END IF\n        END DO\n        END FUNCTION remove_duplicates\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, 3, 4], [1, 2, 3, 4])\n    call test([1, 2, 3, 2, 4, 3, 5], [1, 4, 5])\n\n\n    contains\n    subroutine test (r, ra)\n        implicit none\n        INTEGER, DIMENSION(:), INTENT(IN) :: r\n        INTEGER, DIMENSION(:), INTENT(IN) :: ra\n        INTEGER, DIMENSION(:), ALLOCATABLE:: a\n            logical :: exists\n            logical :: result\n            inquire(file='result.txt', exist=exists)\n            a = remove_duplicates(r)\n            call judge(a, ra, result)\n            if (result.eqv. .false.) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n      \n        subroutine judge(arr1, arr2,result) \n          INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n          LOGICAL, intent(INOUT) :: result\n          INTEGER :: i\n          \n          result = .TRUE.\n          IF (SIZE(arr1) /= SIZE(arr2)) THEN\n              result = .FALSE.\n              RETURN\n          END IF\n          \n          DO i = 1, SIZE(arr1)\n              IF (arr1(i) /= arr2(i)) THEN\n                  result = .FALSE.\n                  RETURN\n              END IF\n          END DO\n      END subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/31", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION is_prime(n) RESULT(result)\n!your code\nEND FUNCTION is_prime\nEND MODULE test_module \"\n functionality:\nReturn true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n", "canonical_solution": "MODULE test_module\n CONTAINS\n FUNCTION is_prime(n) RESULT(result)\n IMPLICIT NONE\n INTEGER, INTENT(IN) :: n\n LOGICAL :: result\n INTEGER :: k\n result=.TRUE.\n IF(n<2) THEN\n result=.False.\n ELSE IF(n==2) THEN\n result = .TRUE.\n ELSE\n DO k=2,N/2+1,1\n IF(MOD(n,k)==0) THEN\n result=.False.\n EXIT\n END IF\n END DO\n END IF\n END FUNCTION is_prime\nEND MODULE test_module\n","test": "PROGRAM main\n USE test_module\n IMPLICIT NONE\n call test(6, .False.)\n call test(101, .True.)\n call test(11, .True.)\n call test(13441, .True.)\n call test(61, .True.)\n call test(4, .False.)\n call test(1, .False.)\n call test(5, .True.)\n call test(11, .True.)\n call test(17, .True.)\n call test(517, .False.)\n call test(117, .False.)\n call test(1344119, .False.)\n contains\n subroutine test (r,ra)\n implicit none\n integer, intent(in) :: r\n logical, intent(in) :: ra\n logical :: a\n logical :: exists\n inquire(file='result.txt', exist=exists)\n a = is_prime(r)\n if (a .neqv. ra) then\n if (exists) then\n open(1, file = 'result.txt', status='old')\n else\n open(1, file = 'result.txt', status='new')\n end if\n write(1,)'F', a, ra\n end if\n end subroutine\nEND PROGRAM main"}
{"task_id": "test/34", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION remove_duplicates(numbers) RESULT(result)\n!your code\nEND FUNCTION remove_duplicates\nEND MODULE test_module \"\n functionality:\nReturn sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result, arr\n        INTEGER :: len, N, count,M,tmp\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=numbers(N)\n        END DO\n\n        DO WHILE(len > 1)\n            DO M=2,len,1\n                IF(arr(M-1)>arr(M)) THEN\n                    tmp=arr(M)\n                    arr(M)=arr(M-1)\n                    arr(M-1)=tmp\n                END IF\n            END DO\n            len=len-1\n        END DO\n        len=SIZE(numbers)\n        DO N=2,len,1\n            IF(arr(N)==arr(N-1)) THEN\n                count=count+1\n            END IF\n        END DO\n        ALLOCATE(result(len-count))\n        M=2\n        result(1)=arr(1)\n        DO N=2,len,1\n            IF(arr(N)/=arr(N-1)) THEN\n                result(M)=arr(N)\n                M=M+1\n            END IF\n        END DO\n\n        END FUNCTION remove_duplicates\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([5, 3, 5, 2, 3, 3, 9, 0, 123], [0, 2, 3, 5, 9, 123])\n    contains\n    subroutine test (r, ra)\n        implicit none\n        INTEGER, DIMENSION(:), INTENT(IN) :: r\n        INTEGER, DIMENSION(:), INTENT(IN) :: ra\n        INTEGER, DIMENSION(:), ALLOCATABLE:: a\n            logical :: exists\n            logical :: result\n            inquire(file='result.txt', exist=exists)\n            a = remove_duplicates(r)\n            call judge(a, ra, result)\n            if (result.eqv. .false.) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n\n        subroutine judge(arr1, arr2,result) \n          INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n          LOGICAL, intent(INOUT) :: result\n          INTEGER :: i\n          \n          result = .TRUE.\n          IF (SIZE(arr1) /= SIZE(arr2)) THEN\n              result = .FALSE.\n              RETURN\n          END IF\n          \n          DO i = 1, SIZE(arr1)\n              IF (arr1(i) /= arr2(i)) THEN\n                  result = .FALSE.\n                  RETURN\n              END IF\n          END DO\n      END subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/35", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION max_element(numbers) RESULT(result)\n!your code\nEND FUNCTION max_element\nEND MODULE test_module \"\n functionality:\nReturn maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION max_element(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER :: result\n        INTEGER :: len, N\n        result = numbers(1)\n        len = SIZE(numbers)\n        \n        DO N=1,len,1\n            result=MAX(result,numbers(N))\n            \n        END DO\n\n        END FUNCTION max_element\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1, 2, 3], 3)\n    call test([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10], 124)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, DIMENSION(:), intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = max_element(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/36", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION fizz_buzz(numbers) RESULT(result)\n!your code\nEND FUNCTION fizz_buzz\nEND MODULE test_module \"\n functionality:\nReturn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n  ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION fizz_buzz(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: numbers\n        INTEGER :: result\n        INTEGER :: N,tmp\n        result = 0\n        \n        DO N=11,numbers-1,1\n            IF(MOD(N,11)==0 .OR. MOD(N,13)==0) THEN\n                tmp = N\n                DO WHILE(tmp/=0)\n                    IF(MOD(tmp,10)==7) THEN\n                        \n                        result=result+1\n                        \n                    END IF\n                    tmp=tmp/10\n                END DO\n            END IF\n            \n        END DO\n\n        END FUNCTION fizz_buzz\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(50,0)\n    call test(78,2)\n    call test(79,3)\n    call test(100,3)\n    call test(200,6)\n    call test(4000,192)\n    call test(10000,639)\n    call test(100000,8026)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = fizz_buzz(r)\n            if (ABS(a-ra)>1e-5) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/37", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION remove_duplicates(numbers) RESULT(arr)\n!your code\nEND FUNCTION remove_duplicates\nEND MODULE test_module \"\n functionality:\nThis function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(arr)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: arr\n        INTEGER :: len, N, count,M,tmp\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=numbers(N)\n        END DO\n\n        DO WHILE(len > 1)\n            DO M=3,len,2\n                IF(arr(M-2)>arr(M)) THEN\n                    tmp=arr(M)\n                    arr(M)=arr(M-2)\n                    arr(M-2)=tmp\n                END IF\n            END DO\n            len=len-2\n        END DO\n        \n        END FUNCTION remove_duplicates\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, 3], [1, 2, 3])\n    call test([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    call test([5, 8, -12, 4, 23, 2, 3, 11, 12, -10], [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = remove_duplicates(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/39", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION prime_fib(n) RESULT(result)\n!your code\nEND FUNCTION prime_fib\nEND MODULE test_module \"\n functionality:\nprime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION is_prime(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        LOGICAL :: result\n        INTEGER :: k\n        result=.TRUE.\n        IF(n<2) THEN\n            result=.False.\n        ELSE IF(n==2) THEN\n            result = .TRUE.\n        ELSE\n            DO k=2,n/2+1,1\n                IF(MOD(n,k)==0) THEN\n                    result=.False.\n                    EXIT\n                END IF\n            END DO\n        END IF\n        END FUNCTION is_prime\n\n        FUNCTION prime_fib(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            INTEGER :: k, tmp1, tmp2\n            tmp1 = 1\n            tmp2 = 1\n            k = 0\n            DO WHILE(k /= n)\n                result = tmp1+tmp2\n                tmp1 = tmp2\n                tmp2 = result\n                IF(is_prime(result)) THEN\n                    k=k+1\n                END IF\n            END DO\n\n            END FUNCTION prime_fib\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(1, 2)\n    call test(2, 3)\n    call test(3, 5)\n    call test(4, 13)\n    call test(5, 89)\n    call test(6, 233)\n    call test(7, 1597)\n    call test(8, 28657)\n    call test(9, 514229)\n    call test(10, 433494437)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = prime_fib(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/40", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION triples_sum_to_zero(numbers) RESULT(result)\n!your code\nEND FUNCTION triples_sum_to_zero\nEND MODULE test_module \"\n functionality:\ntriples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION triples_sum_to_zero(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        LOGICAL :: result\n        INTEGER :: len, N, M, K\n        len = SIZE(numbers)\n        result=.FALSE.\n        \n        DO N=1,len,1\n            DO M=N+1,len,1\n                DO K=M+1,len,1\n                    IF(numbers(N)+numbers(M)+numbers(K)==0) THEN\n                        result=.TRUE.\n                        EXIT\n                    END IF\n                END DO\n            END DO\n        END DO\n        END FUNCTION triples_sum_to_zero\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1, 3, 5, 0], .FALSE.)\n    call test([1, 3, 5, -1], .FALSE.)\n    call test([1, 3, -2, 1], .TRUE.)\n    call test([1, 2, 3, 7], .FALSE.)\n    call test([1, 2, 5, 7], .FALSE.)\n    call test([2, 4, -5, 3, 9, 7], .TRUE.)\n    call test([1], .FALSE.)\n    call test([1, 3, 5, -100], .FALSE.)\n    call test([100, 3, 5, -100], .FALSE.)\n\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = triples_sum_to_zero(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/41", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION car_race_collision(n) RESULT(result)\n!your code\nEND FUNCTION car_race_collision\nEND MODULE test_module \"\n functionality:\nImagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION car_race_collision(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            result = n*n\n            END FUNCTION car_race_collision\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(2, 4)\n    call test(3, 9)\n    call test(4, 16)\n    call test(8, 64)\n    call test(10, 100)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = car_race_collision(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n\nEND PROGRAM main\n"}
{"task_id": "test/42", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION incr_list(numbers) RESULT(result)\n!your code\nEND FUNCTION incr_list\nEND MODULE test_module \"\n functionality:\nReturn list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION incr_list(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n        \n        len = SIZE(numbers)\n        ALLOCATE(result(len))\n        \n        DO N=1,len,1\n            \n            result(N)=numbers(n)+1\n        END DO\n        END FUNCTION incr_list\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([3, 2, 1], [4, 3, 2])\n    call test([5, 2, 5, 2, 3, 3, 9, 0, 123], [6, 3, 6, 3, 4, 4, 10, 1, 124])\n\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = incr_list(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/45", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION triangle_area(a, h) RESULT(result)\n!your code\nEND FUNCTION triangle_area\nEND MODULE test_module \"\n functionality:\nGiven length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION triangle_area(a, h) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: a, h\n            REAL :: result\n            result = REAL(a)*REAL(h)/2\n            END FUNCTION triangle_area\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(5,3,7.5)\n    call test(2,2,2.0)\n    call test(10,8,40.0)\n   \n    contains\n    subroutine test (p1,p2,st)\n        implicit none\n            INTEGER, intent(in) :: p1,p2\n            real, intent(in) :: st\n            real :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = triangle_area(p1,p2)\n            if (ABS(a-st)>1e-5) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, st\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/46", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION fib4(n) RESULT(result)\n!your code\nEND FUNCTION fib4\nEND MODULE test_module \"\n functionality:\nThe Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION fib4(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            INTEGER :: k, tmp1, tmp2, tmp3, tmp0\n            tmp0 = 0\n            tmp1 = 0\n            tmp2 = 2\n            tmp3 = 0\n            \n            IF(n==0) THEN\n                result=tmp0\n            ELSE IF(n==1) THEN\n                result=tmp1\n            ELSE IF(n==2) THEN\n                result=tmp2\n            ELSE IF(n==3) THEN\n                result=tmp3\n            ELSE \n                DO k=3,n-1,1\n                    result=tmp0+tmp1+tmp2+tmp3\n                    tmp0=tmp1\n                    tmp1=tmp2\n                    tmp2=tmp3\n                    tmp3=result\n                END DO\n            END IF\n\n        END FUNCTION fib4\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(10,104)\n    call test(5,4)\n    call test(8,28)\n    call test(12,386)\n    \n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = fib4(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/47", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION remove_duplicates(numbers) RESULT(result)\n!your code\nEND FUNCTION remove_duplicates\nEND MODULE test_module \"\n functionality:\nReturn median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION remove_duplicates(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: arr\n        INTEGER :: len, N, count,M,tmp\n        REAL :: result\n        len=SIZE(numbers)\n        ALLOCATE(arr(len))\n        count=0\n        DO N=1,len,1\n            arr(N)=numbers(N)\n        END DO\n\n        DO WHILE(len > 1)\n            DO M=2,len,1\n                IF(arr(M-1)>arr(M)) THEN\n                    tmp=arr(M)\n                    arr(M)=arr(M-1)\n                    arr(M-1)=tmp\n                END IF\n            END DO\n            len=len-1\n        END DO\n        len=SIZE(numbers)\n        IF(MOD(len,2)==1) THEN\n            result=REAL(arr(len/2+1))\n        ELSE\n            result=(REAL(arr(len/2)+arr(len/2+1)))/2\n        END IF\n\n        END FUNCTION remove_duplicates\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([3, 1, 2, 4, 5], 3.0)\n    call test([-10, 4, 6, 1000, 10, 20], 8.0)\n    call test([5], 5.0)\n    call test([6, 5], 5.5)\n    call test([8, 1, 3, 9, 9, 2, 7], 7.0)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      real, intent(in) :: ra\n      real :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = remove_duplicates(r)\n      if (ABS(ra-a)>1e-5) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/49", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION modp(n, p) RESULT(result)\n!your code\nEND FUNCTION modp\nEND MODULE test_module \"\n functionality:\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION modp(n, p) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n, p\n            INTEGER :: result, i\n            result=1\n            DO i=1,n,1\n                result=MOD(result*2,p)\n            END Do\n           \n            END FUNCTION modp\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(3,5, 3)\n    call test(1101, 101, 2)\n    call test(0, 101, 1)\n    call test(3, 11, 8)\n    call test(100, 101, 1)\n    call test(30, 5, 4)\n    call test(31, 5, 3)\n    contains\n    subroutine test (p1,p2,ra)\n        implicit none\n            INTEGER, intent(in) :: p1,p2\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = modp(p1,p2)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/52", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION below_threshold(numbers, t) RESULT(result)\n!your code\nEND FUNCTION below_threshold\nEND MODULE test_module \"\n functionality:\nReturn True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION below_threshold(numbers, t) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, INTENT(IN) :: t\n        LOGICAL :: result\n        INTEGER :: len, N\n\n        len = SIZE(numbers)\n        result = .TRUE.\n        \n        DO N=1,len,1\n            IF(numbers(N)>=t) THEN\n                result=.FALSE.\n            END IF\n        END DO\n        END FUNCTION below_threshold\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1, 2, 4, 10], 100, .true.)\n    call test([1, 20, 4, 10], 5, .false.)\n    call test([1, 20, 4, 10], 21, .true.)\n    call test([1, 20, 4, 10], 22, .true.)\n    call test([1, 8, 4, 10], 11, .true.)\n    call test([1, 8, 4, 10], 10, .false.)\n\n    contains\n  subroutine test (p1, p2, ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: p1\n      INTEGER, INTENT(IN) :: p2\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = below_threshold(p1, p2)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/53", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION add(x, y) RESULT(result)\n!your code\nEND FUNCTION add\nEND MODULE test_module \"\n functionality:\nAdd two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION add(x, y) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: x,y\n        INTEGER :: result\n        result=x+y\n        END FUNCTION add\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(2,3,5)\n    call test(5,7,12)\n    contains\n    subroutine test (p1,p2,ra)\n        implicit none\n            INTEGER, intent(in) :: p1,p2\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = add(p1,p2)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/55", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION fib(n) RESULT(result)\n!your code\nEND FUNCTION fib\nEND MODULE test_module \"\n functionality:\nReturn n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION fib(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            INTEGER :: k, tmp1, tmp2\n            tmp1 = 0\n            tmp2 = 1\n            result = tmp2\n            k = 1\n            DO WHILE(k /= n)\n                result = tmp1+tmp2\n                tmp1 = tmp2\n                tmp2 = result\n                k=k+1\n\n            END DO\n\n            END FUNCTION fib\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(10, 55)\n    call test(1, 1)\n    call test(8, 21)\n    call test(11, 89)\n    call test(12, 144)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = fib(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n\nEND PROGRAM main\n"}
{"task_id": "test/57", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION monotonic(numbers) RESULT(result)\n!your code\nEND FUNCTION monotonic\nEND MODULE test_module \"\n functionality:\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n        FUNCTION monotonic(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        LOGICAL :: result,before,now\n        INTEGER :: len, N\n        \n        len = SIZE(numbers)\n        result=.TRUE.\n        IF(len>2) THEN\n            before=(numbers(1)<numbers(2))\n        END IF\n\n        DO N=3,len,1\n            now=numbers(N)>numbers(N-1)\n            IF(.NOT. (now .EQV. before)) THEN\n                result=.FALSE.\n                EXIT\n            END IF\n            before=now\n        END DO\n        END FUNCTION monotonic\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, 4, 10], .true.)\n    call test([1, 2, 4, 20], .true.)\n    call test([1, 20, 4, 10], .false.)\n    call test([4, 1, 0, -10], .true.)\n    call test([4, 1, 1, 0], .true.)\n    call test([1, 2, 3, 2, 5, 60], .false.)\n    call test([1, 2, 3, 4, 5, 60], .true.)\n    call test([9, 9, 9, 9], .true.)\n\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = monotonic(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/58", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION common(l1, l2) RESULT(result)\n!your code\nEND FUNCTION common\nEND MODULE test_module \"\n functionality:\nReturn sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n>>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION common(l1, l2) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: l1, l2\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result, arr1, arr2, arr3\n        INTEGER :: len1, len2, N, count,M,tmp\n        len1=SIZE(l1)\n        len2=SIZE(l2)\n        ALLOCATE(arr1(len1))\n        ALLOCATE(arr2(len2))\n        ALLOCATE(arr3(MIN(len1,len2)))\n        count=0\n        DO N=1,len1,1\n            arr1(N)=l1(N)\n        END DO\n        DO N=1,len2,1\n            arr2(N)=l2(N)\n        END DO\n        DO WHILE(len1 > 1)\n            DO M=2,len1,1\n                IF(arr1(M-1)>arr1(M)) THEN\n                    tmp=arr1(M)\n                    arr1(M)=arr1(M-1)\n                    arr1(M-1)=tmp\n                END IF\n            END DO\n            len1=len1-1\n        END DO\n        DO WHILE(len2 > 1)\n            DO M=2,len2,1\n                IF(arr2(M-1)>arr2(M)) THEN\n                    tmp=arr2(M)\n                    arr2(M)=arr2(M-1)\n                    arr2(M-1)=tmp\n                END IF\n            END DO\n            len2=len2-1\n        END DO\n        len1=SIZE(l1)\n        len2=SIZE(l2)\n        N=1\n        M=1\n        count=0\n        DO N=1,len1,1\n            IF(N==1 .OR. (N>1 .AND. arr1(N)/=arr1(N-1))) THEN\n                DO M=1,len2,1\n                    IF(arr2(M)==arr1(N)) THEN\n                        count=count+1\n                        arr3(count)=arr1(N)\n                        EXIT\n                    END IF\n                END DO\n            END IF\n        END DO\n        ALLOCATE(result(count))\n        DO WHILE(count/=0)\n            result(count) = arr3(count)\n            count=count-1\n        END DO\n        END FUNCTION common\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121], [1, 5, 653])\n    call test([5, 3, 2, 8], [3, 2], [2, 3])\n    call test([4, 3, 2, 8], [3, 2, 4], [2, 3, 4])\n    contains\n  subroutine test (p1,p2, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: p1,p2\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = common(p1,p2)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/59", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION largest_prime_factor(n) RESULT(result)\n!your code\nEND FUNCTION largest_prime_factor\nEND MODULE test_module \"\n functionality:\nReturn the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION is_prime(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        LOGICAL :: result\n        INTEGER :: k\n        result=.TRUE.\n        IF(n<2) THEN\n            result=.False.\n        ELSE IF(n==2) THEN\n            result = .TRUE.\n        ELSE\n            DO k=2,n/2+1,1\n                IF(MOD(n,k)==0) THEN\n                    result=.False.\n                    EXIT\n                END IF\n            END DO\n        END IF\n        END FUNCTION is_prime\n\n        FUNCTION largest_prime_factor(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n            result = n/2+1\n            \n            DO WHILE(result>1)\n                IF(MOD(n,result)==0) THEN\n                    IF(is_prime(result)) THEN\n                        EXIT\n                    END IF    \n                END IF\n                result = result -1\n            END DO\n\n            END FUNCTION largest_prime_factor\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(15, 5)\n    call test(27, 3)\n    call test(63, 7)\n    call test(330, 11)\n    call test(13195, 29)\n    call test(2048, 2)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = largest_prime_factor(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\n\nEND PROGRAM main\n"}
{"task_id": "test/60", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION sum_to_n(n) RESULT(result)\n!your code\nEND FUNCTION sum_to_n\nEND MODULE test_module \"\n functionality:\nsum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION sum_to_n(n) RESULT(result)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: result\n\n            result = (1+n)*n/2\n           \n            END FUNCTION sum_to_n\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(1, 1)\n    call test(6, 21)\n    call test(11, 66)\n    call test(30, 465)\n    call test(100, 5050)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = sum_to_n(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/62", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION derivative(numbers) RESULT(result)\n!your code\nEND FUNCTION derivative\nEND MODULE test_module \"\n functionality:\nxs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n        FUNCTION derivative(numbers) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: numbers\n        INTEGER, DIMENSION(:), ALLOCATABLE :: result\n        INTEGER :: len, N\n        len=SIZE(numbers)\n\n        IF(len==1) THEN\n            ALLOCATE(result(len))\n            result(1)=0\n        ELSE\n            ALLOCATE(result(len-1))\n            DO N=2,len,1\n                result(N-1)=numbers(n)*(N-1)\n            END DO\n        END IF\n\n        END FUNCTION derivative\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([3, 1, 2, 4, 5], [1, 4, 12, 20])\n    call test([1, 2, 3], [2, 6])\n    call test([3, 2, 1], [2, 2])\n    call test([3, 2, 1, 0, 4], [2, 2, 0, 16])\n    !call test([1], [])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = derivative(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/63", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION fibfib(n) RESULT(result)\n!your code\nEND FUNCTION fibfib\nEND MODULE test_module \"\n functionality:\nThe FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n    FUNCTION fibfib(n) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: result\n        INTEGER :: i\n        INTEGER, DIMENSION(n) :: fibfib_array\n        IF (n == 0) THEN\n            result = 0\n        ELSE IF (n == 1) THEN\n            result = 0\n        ELSE IF (n == 2) THEN\n            result = 1\n        ELSE\n            fibfib_array(1) = 0\n            fibfib_array(2) = 1\n            fibfib_array(3) = 1\n            \n            DO i = 4, n\n                fibfib_array(i) = fibfib_array(i-1) + fibfib_array(i-2) + fibfib_array(i-3)\n            END DO\n            \n            result = fibfib_array(n)\n        END IF\n        \n    END FUNCTION fibfib\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(2,1)\n    call test(1,0)\n    call test(5,4)\n    call test(8,24)\n    call test(10,81)\n    call test(12,274)\n    call test(14,927)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = fibfib(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/68", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION pluck(arr) RESULT(output)\n!your code\nEND FUNCTION pluck\nEND MODULE test_module \"\n functionality:\nGiven an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n   The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n    FUNCTION pluck(arr) RESULT(output)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: arr\n        INTEGER, DIMENSION(2) :: output\n        INTEGER :: i, smallest_value, smallest_index, flag\n        flag=0\n        output = [0, 0]\n        IF (SIZE(arr) > 0) THEN\n            smallest_value = MAXVAL(arr) + 1\n            smallest_index = 0\n            DO i = 1, SIZE(arr)\n                IF (MOD(arr(i), 2) == 0 .AND. arr(i) < smallest_value) THEN\n                    flag = 1\n                    smallest_value = arr(i)\n                    smallest_index = i\n                END IF\n            END DO\n            IF (smallest_index > 0) THEN\n                output(1) = smallest_value\n                output(2) = smallest_index-1\n            END IF\n            IF (flag == 0) THEN\n                output(1) = -1\n                output(2) = -1\n            END IF\n        END IF\n    \n    END FUNCTION pluck\n    \nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([4,2,3],[2, 1])\n    call test([1,2,3],[2, 1])\n    call test([5, 0, 3, 0, 4, 2],[0, 1])\n    call test([1, 2, 3, 0, 5, 3],[0, 3])\n    call test([5, 4, 8, 4 ,8],[4, 1])\n    call test([7, 6, 7, 1],[6, 1])\n    !call test([7, 9, 7, 1],[])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = pluck(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/69", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION search(lst) RESULT(output)\n!your code\nEND FUNCTION search\nEND MODULE test_module \"\n functionality:\nYou are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n    FUNCTION search(lst) RESULT(output)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: lst\n        INTEGER :: output, i, j, count\n        output = -1\n        DO i = 1, SIZE(lst)\n            count = 0\n            DO j = 1, SIZE(lst)\n                IF (lst(j) == lst(i)) THEN\n                    count = count + 1\n                END IF\n            END DO\n            IF (count >= lst(i) .AND. lst(i) > 0) THEN\n                output = MAX(output, lst(i))\n            END IF\n        END DO\n    END FUNCTION search\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([5, 5, 5, 5, 1], 1)\n    call test([4, 1, 4, 1, 4, 4], 4)\n    call test([3, 3], -1)\n    call test([8, 8, 8, 8, 8, 8, 8, 8], 8)\n    call test([2, 3, 3, 2, 2], 2)\n    call test([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1], 1)\n    call test([3, 2, 8, 2], 2)\n    call test([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10], 1)\n    call test([8, 8, 3, 6, 5, 6, 4], -1)\n    call test([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9], 1)\n    call test([1, 9, 10, 1, 3], 1)\n    call test([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10], 5)\n    call test([1], 1)\n    call test([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5], 4)\n    call test([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10], 2)\n    call test([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4], 4)\n    call test([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7], 4)\n    call test([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1], 2)\n    call test([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8], -1)\n    call test([10], -1)\n    call test([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2], 2)\n    call test([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8], 1)\n    call test([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6], 1)\n    call test([3, 10, 10, 9, 2], -1)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      INTEGER, intent(in) :: ra\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = search(r)\n      if (a/=ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/70", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION strange_sort_list(lst) RESULT(output)\n!your code\nEND FUNCTION strange_sort_list\nEND MODULE test_module \"\n functionality:\nGiven list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n    FUNCTION strange_sort_list(lst) RESULT(output)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: lst\n        INTEGER, DIMENSION(:), ALLOCATABLE :: output\n        INTEGER :: i, j, min_idx, max_idx, min_val, max_val, tmp1, tmp2\n\n        ALLOCATE(output(SIZE(lst)))\n        DO i=1,SIZE(lst),1\n            output(i) = lst(i)\n        END DO\n\n        DO i = 1, SIZE(lst), 2\n            min_idx = i\n            min_val = output(i)\n            max_idx = i\n            max_val = output(i)\n\n            IF(i+1<=SIZE(lst)) THEN\n                IF(output(i+1) < output(i)) THEN\n                    min_idx=i+1\n                    min_val=output(i+1)\n                else\n                    max_idx=i+1\n                    max_val=output(i+1)\n                END IF\n            END IF\n\n            DO j = i+2, SIZE(lst), 1\n                IF (output(j) < min_val) THEN\n                    min_idx = j\n                    min_val = output(j)\n                END IF\n                IF (output(j) > max_val) THEN\n                    max_idx = j\n                    max_val = output(j)\n                END IF\n            END DO\n\n            tmp1 = output(i)\n\n            IF (i+1 <= SIZE(lst)) THEN\n                tmp2 = output(i+1)\n            END IF\n            output(i) = min_val\n            output(min_idx) = tmp1\n            IF (i+1 <= SIZE(lst)) THEN\n                output(i+1) = max_val\n                output(max_idx) = tmp2\n            END IF\n        END DO\n\n    END FUNCTION strange_sort_list\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, 3, 4],[1, 4, 2, 3]) \n    call test([5, 6, 7, 8, 9],[5, 9, 6, 8, 7]) \n    call test([1, 2, 3, 4, 5],[1, 5, 2, 4, 3]) \n    call test([5, 6, 7, 8, 9, 1],[1, 9, 5, 8, 6, 7]) \n    call test([5, 5, 5, 5],[5, 5, 5, 5]) \n    call test([1,2,3,4,5,6,7,8],[1, 8, 2, 7, 3, 6, 4, 5]) \n    call test([0,2,2,2,5,5,-5,-5],[-5, 5, -5, 5, 0, 2, 2, 2]) \n    call test([111111],[111111]) \n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = strange_sort_list(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/71", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION triangle_area(a, b, c) RESULT(area)\n!your code\nEND FUNCTION triangle_area\nEND MODULE test_module \"\n functionality:\nGiven the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n  ", "canonical_solution": "MODULE test_module\n    IMPLICIT NONE\n    CONTAINS \n    FUNCTION triangle_area(a, b, c) RESULT(area)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: a, b, c\n        REAL :: s, area\n        IF (a + b > c .AND. a + c > b .AND. b + c > a) THEN\n            s = (a + b + c) / 2.0\n            area = SQRT(s * (s - a) * (s - b) * (s - c))\n        ELSE\n            area = -1.0\n        END IF  \n    END FUNCTION triangle_area\n    \nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3, 4, 5,6.00)\n    call test(1, 2, 10,-1.00)\n    call test(4, 8, 5,8.18)\n    call test(2, 2, 2,1.73)\n    call test(1, 2, 3,-1.00)\n    call test(10, 5, 7,16.25)\n    call test(2, 6, 3,-1.0)\n    call test(1, 1, 1,0.43)\n    call test(2, 2, 10,-1.0)\n    contains\n    subroutine test (p1,p2,p3,ra)\n        implicit none\n            INTEGER, intent(in) :: p1,p2,p3\n            real, intent(in) :: ra\n            real :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = triangle_area(p1,p2,p3)\n            if (ABS(a-ra)>0.01) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/72", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION will_it_fly(q, w) RESULT(result)\n!your code\nEND FUNCTION will_it_fly\nEND MODULE test_module \"\n functionality:\nWrite a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n", "canonical_solution": "MODULE test_module\n    CONTAINS\n    FUNCTION will_it_fly(q, w) RESULT(result)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: q\n        INTEGER, INTENT(IN) :: w\n        INTEGER :: sum, i\n        LOGICAL :: result\n\n        sum = 0\n        result = .FALSE.\n        DO i = 1, SIZE(q)\n            IF (q(i) /= q(SIZE(q)-i+1)) THEN\n                RETURN\n            END IF\n        END DO\n        DO i = 1, SIZE(q)\n            sum = sum + q(i)\n        END DO\n        IF (sum <= w) THEN\n            result = .TRUE.\n        END IF\n\n    END FUNCTION will_it_fly\n\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([3, 2, 3], 9, .true.)\n    call test([1, 2], 5, .false.)\n    call test([3], 5, .true.)\n    call test([3, 2, 3], 1, .false.)\n    call test([1, 2, 3], 6, .false.)\n    call test([5], 5, .true.)\n\n    contains\n  subroutine test (p1,p2,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: p1\n      INTEGER, INTENT(IN) :: p2\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = will_it_fly(p1,p2)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/73", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION smallest_change(inp) RESULT(count)\n!your code\nEND FUNCTION smallest_change\nEND MODULE test_module \"\n functionality:\nGiven an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n", "canonical_solution": "MODULE test_module\n CONTAINS\n FUNCTION smallest_change(inp) RESULT(count)\n IMPLICIT NONE\n INTEGER, DIMENSION(:), INTENT(IN) :: inp\n INTEGER, DIMENSION(:), ALLOCATABLE :: arr\n INTEGER :: count, i\n ALLOCATE(arr(SIZE(inp)))\n count = 0\n DO i=1,SIZE(arr),1\n arr(i)=inp(i)\n END DO\n DO i = 1, SIZE(arr)/2, 1\n IF (arr(i) /= arr(SIZE(arr)-i+1)) THEN\n IF (arr(i) < arr(SIZE(arr)-i+1)) THEN\n arr(i) = arr(SIZE(arr)-i+1)\n ELSE\n arr(SIZE(arr)-i+1) = arr(i)\n END IF\n count = count + 1\n END IF\n END DO\n END FUNCTION smallest_change\nEND MODULE test_module\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1,2,3,5,4,7,9,6],4)\n    call test([1, 2, 3, 4, 3, 2, 2],1)\n    call test([1, 4, 2],1)\n    call test([1, 4, 4, 2],1)\n    call test([1, 2, 3, 2, 1],0)\n    call test([3, 1, 1, 3],0)\n    call test([1],0)\n    call test([0, 1],1)\n\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      INTEGER, intent(in) :: ra\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = smallest_change(r)\n      if (a/=ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/75", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction is_multiply_prime(a) result(found)\n!your code\nEND FUNCTION is_multiply_prime\nEND MODULE test_module \"\n functionality:\nWrite a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function is_multiply_prime(a) result(found)\n        implicit none\n        INTEGER, INTENT(IN) :: a\n        LOGICAL :: found\n        INTEGER :: i, j, k\n        \n        found = .false.\n        DO i = 2, 100\n            IF (.not. is_prime(i)) cycle\n            DO j = 2, 100\n                IF (.not. is_prime(j)) cycle\n                DO k = 2, 100\n                    IF (.not. is_prime(k)) cycle\n                    IF (i*j*k == a) then\n                        found = .true.\n                        return\n                    END IF\n                END DO\n            END DO\n        END DO\n    END FUNCTION is_multiply_prime\n\n    FUNCTION is_prime(n) RESULT(is_prime_num)\n            IMPLICIT NONE\n            INTEGER, INTENT(IN) :: n\n            INTEGER :: i\n            LOGICAL :: is_prime_num\n    \n            is_prime_num = .TRUE.\n    \n            DO i = 2, n-1\n                IF (MOD(n, i) == 0) THEN\n                    is_prime_num = .FALSE.\n                    EXIT\n                END IF\n            END DO\n    END FUNCTION is_prime\nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(5, .false.)\n    call test(30, .true.)\n    call test(8, .true.)\n    call test(10, .false.)\n    call test(125, .true.)\n    call test(3 * 5 * 7, .true.)\n    call test(3 * 6 * 7, .false.)\n    call test(9 * 9 * 9, .false.)\n    call test(9 * 9 * 11, .false.)\n    call test(11 * 13 * 7, .true.)\n\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = is_multiply_prime(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/76", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION is_simple_power(x, n) RESULT(is_simple)\n!your code\nEND FUNCTION is_simple_power\nEND MODULE test_module \"\n functionality:\nYour task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n ", "canonical_solution": "MODULE test_module\n    CONTAINS \n    FUNCTION is_simple_power(x, n) RESULT(is_simple)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: x, n\n        INTEGER :: power\n        LOGICAl :: is_simple\n        power = 0\n        is_simple = .FALSE.\n    \n        DO WHILE (n**power <= x)\n            IF (n**power == x) THEN\n                is_simple = .TRUE.\n                EXIT\n            END IF\n            power = power + 1\n        END DO\n    END FUNCTION is_simple_power\n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(16, 2, .true.)\n    call test(143214, 16, .false.)\n    call test(4, 2, .true.)\n    call test(9, 3, .true.)\n    call test(16, 4, .true.)\n    call test(24, 2, .false.)\n    call test(128, 4, .false.)\n    call test(12, 6, .false.)\n    call test(1, 1, .true.)\n    call test(1, 12, .true.)\n    contains\n  subroutine test (p1,p2,ra)\n  implicit none\n      INTEGER, INTENT(IN) :: p1, p2\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = is_simple_power(p1, p2)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/77", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction iscube(a) result(result)\n!your code\nend function iscube\nEND MODULE test_module \"\n functionality:\nWrite a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    FUNCTION iscube(a) RESULT(is_cube_num)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: a\n        INTEGER :: root, b\n        LOGICAl :: is_cube_num\n        b=a\n    \n        root = ABS(real(b)) ** (1.0 / 3.0)\n        is_cube_num = ((root ** 3 - ABS(a))<1e-2)\n    END FUNCTION iscube    \n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    \n    call test(1, .true.)\n    call test(2, .false.)\n    call test(-1, .true.)\n    call test(64, .true.)\n    call test(180, .false.)\n    call test(1000, .true.)\n    call test(0, .true.)\n    call test(1729, .false.)\n    \n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = iscube(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/78", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction hex_key(num) result(count)\n!your code\nend function hex_key\nEND MODULE test_module \"\n functionality:\nYou have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function hex_key(num) result(count)\n        IMPLICIT NONE\n    CHARACTER(LEN=*), INTENT(IN) :: num\n    INTEGER :: i, count\n\n    count = 0\n    DO i = 1, LEN_TRIM(num)\n        SELECT CASE (num(i:i))\n            CASE ('2', '3', '5', '7', 'B', 'D')\n                count = count + 1\n        END SELECT\n    END DO\n    end function hex_key\nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(\"AB\",1)\n    call test(\"1077E\",2)\n    call test(\"ABED1A33\",4)\n    call test(\"2020\",2)\n    call test(\"123456789ABCDEF0\",6)\n    call test(\"112233445566778899AABBCCDDEEFF00\",12)\n    call test(\"\",0)\n    contains\n    subroutine test (r,ra)\n    implicit none\n        CHARACTER(LEN=*), INTENT(IN) :: r\n        INTEGER, intent(in) :: ra\n        INTEGER :: a\n        logical :: exists\n        inquire(file='result.txt', exist=exists)\n        a = hex_key(r)\n        if (a/=ra) then\n            if (exists) then\n              open(1, file = 'result.txt', status='old')\n            else\n              open(1, file = 'result.txt', status='new')\n            end if\n            write(1,*)'F', a, ra\n        end if\n    end subroutine\nEND PROGRAM main"}
{"task_id": "test/82", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION prime_length(str) RESULT(is_prime)\n!your code\nEND FUNCTION prime_length\nEND MODULE test_module \"\n functionality:\nWrite a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    FUNCTION prime_length(str) RESULT(is_prime)\n        IMPLICIT NONE\n        CHARACTER(LEN=*), INTENT(IN) :: str\n        LOGICAL :: is_prime\n        INTEGER :: length, i\n    \n        length = LEN_TRIM(str)\n        is_prime = .FALSE.\n    \n        IF (length <= 1) THEN\n            RETURN\n        END IF\n    \n        DO i = 2, INT(SQRT(REAL(length)))\n            IF (MOD(length, i) == 0) THEN\n                RETURN\n            END IF\n        END DO\n    \n        is_prime = .TRUE.\n    END FUNCTION prime_length\n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(\"Hello\", .true.)\n    call test(\"abcdcba\", .true.)\n    call test(\"kittens\", .true.)\n    call test(\"orange\", .false.)\n    call test(\"wow\", .true.)\n    call test(\"world\", .true.)\n    call test(\"MadaM\", .true.)\n    call test(\"Wow\", .true.)\n    call test(\"\", .false.)\n    call test(\"HI\", .true.)\n    call test(\"go\", .true.)\n    call test(\"gogo\", .false.)\n    call test(\"aaaaaaaaaaaaaaa\", .false.)\n    call test(\"Madam\", .true.)\n    call test(\"M\", .false.)\n    call test(\"0\", .false.)\n    contains\n  subroutine test (r,ra)\n  implicit none\n  CHARACTER(LEN=*), INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = prime_length(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/83", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION starts_one_ends(n) RESULT(count)\n!your code\nEND FUNCTION starts_one_ends\nEND MODULE test_module \"\n functionality:\nGiven a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    FUNCTION starts_one_ends(n) RESULT(count)\n        IMPLICIT NONE\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: count, i\n    \n        count = 0\n    \n        IF (n < 1) THEN\n            RETURN\n        END IF\n    \n        IF (n == 1) THEN\n            count = 1\n        ELSE\n            count = 18  \n            DO i = 2, n - 1\n                count = count * 10\n            END DO\n            \n        END IF\n    END FUNCTION starts_one_ends\n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(1,1)\n    call test(2,18)\n    call test(3,180)\n    call test(4,1800)\n    call test(5,18000)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = starts_one_ends(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/85", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction add(lst) result(total)\n!your code\nend function add\nEND MODULE test_module \"\n functionality:\nGiven a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    FUNCTION add(lst) RESULT(total)\n        IMPLICIT NONE\n        INTEGER, DIMENSION(:), INTENT(IN) :: lst\n        INTEGER :: total\n        INTEGER :: i\n        \n        total = 0\n        do i = 2, size(lst), 2\n            if (mod(lst(i), 2) == 0) then\n                total = total + lst(i)\n            end if\n        end do\n    end function add\n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([4, 2, 6, 7],2)\n    call test([4, 88],88)\n    call test([4, 5, 6, 7, 2, 122],122)\n    call test([4, 0, 6, 7],0)\n    call test([4, 4, 6, 8],12)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      INTEGER, intent(in) :: ra\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = add(r)\n      if (a/=ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/88", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction sort_array(arr) result(sorted_arr)\n!your code\nend function sort_array\nEND MODULE test_module \"\n functionality:\nGiven an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function sort_array(arr) result(sorted_arr)\n        integer, dimension(:), intent(in) :: arr\n        integer, dimension(:), allocatable :: sorted_arr\n        integer :: n, sum_first_last\n    \n        n = size(arr)\n        sorted_arr = arr\n    \n        if (n > 0) then\n            sum_first_last = arr(1) + arr(n)\n            if (mod(sum_first_last, 2) == 0) then\n                call descending_sort(sorted_arr)\n            else\n                call ascending_sort(sorted_arr)\n            end if\n        end if\n    \n    contains\n    \n        subroutine descending_sort(arr)\n            integer, dimension(:), intent(inout) :: arr\n            integer :: i, j, temp\n    \n            do i = 1, size(arr) - 1\n                do j = i + 1, size(arr)\n                    if (arr(i) < arr(j)) then\n                        temp = arr(i)\n                        arr(i) = arr(j)\n                        arr(j) = temp\n                    end if\n                end do\n            end do\n        end subroutine descending_sort\n    \n        subroutine ascending_sort(arr)\n            integer, dimension(:), intent(inout) :: arr\n            integer :: i, j, temp\n    \n            do i = 1, size(arr) - 1\n                do j = i + 1, size(arr)\n                    if (arr(i) > arr(j)) then\n                        temp = arr(i)\n                        arr(i) = arr(j)\n                        arr(j) = temp\n                    end if\n                end do\n            end do\n        end subroutine ascending_sort\n    \n    end function sort_array\nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE   \n    call test([5],[5])\n    call test([2, 4, 3, 0, 1, 5],[0, 1, 2, 3, 4, 5])\n    call test([2, 4, 3, 0, 1, 5, 6],[6, 5, 4, 3, 2, 1, 0])\n    call test([2, 1],[1, 2])\n    call test([15, 42, 87, 32 ,11, 0],[0, 11, 15, 32, 42, 87])\n    call test([21, 14, 23, 11],[23, 21, 14, 11])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = sort_array(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main"}
{"task_id": "test/94", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction skjkasdkd(lst) result(sum)\n!your code\nend function skjkasdkd\nEND MODULE test_module \"\n functionality:\nYou are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function skjkasdkd(lst) result(sum)\n        implicit none\n        integer, intent(in) :: lst(:)\n        integer :: i, j, num, sum, max_prime\n        logical :: is_prime\n        \n        max_prime = -1  ! Initialize the largest prime value to a negative number\n        \n        do i = 1, size(lst)\n          num = lst(i)\n          \n          ! Check if num is a prime number\n          is_prime = .true.\n          if (num <= 1) then\n            is_prime = .false.\n          else\n            do j = 2, num - 1\n              if (mod(num, j) == 0) then\n                is_prime = .false.\n                exit\n              endif\n            enddo\n          endif\n          \n          ! Update the largest prime value if necessary\n          if (is_prime .and. num > max_prime) then\n            max_prime = num\n          endif\n        enddo\n        \n        sum = 0\n        \n        ! Calculate the sum of digits of the largest prime value\n        if (max_prime > 0) then\n          do while (max_prime > 0)\n            sum = sum + mod(max_prime, 10)\n            max_prime = max_prime / 10\n          enddo\n        endif\n        \n      end function skjkasdkd\n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3],10)\n    call test([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1],25)\n    call test([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3],13)\n    call test([0,724,32,71,99,32,6,0,5,91,83,0,5,6],11)\n    call test([0,81,12,3,1,21],3)\n    call test([0,8,1,2,1,7],7)\n    call test([8191],19)\n    call test([8191, 123456, 127, 7],19)\n    call test([127, 97, 8192],10)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      INTEGER, intent(in) :: ra\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = skjkasdkd(r)\n      if (a/=ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main"}
{"task_id": "test/96", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction count_up_to(n) result(primes)\n!your code\nend function count_up_to\nEND MODULE test_module \"\n functionality:\nImplement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function count_up_to(n) result(primes)\n        integer, intent(in) :: n\n        integer, allocatable :: primes(:)\n        integer :: num, count\n      \n        count = 0\n        do num = 2, n - 1\n          if (is_prime(num)) then\n            count = count + 1\n          end if\n        end do\n      \n        allocate(primes(count))\n        count = 1\n        do num = 2, n - 1\n          if (is_prime(num)) then\n            primes(count) = num\n            count = count + 1\n          end if\n        end do\n    end function count_up_to\n    \n    function is_prime(num) result(isprime)\n          integer, intent(in) :: num\n          integer :: i\n          LOGICAL :: isprime\n      \n          if (num < 2) then\n            isprime = .false.\n            return\n          end if\n      \n          do i = 2, int(sqrt(real(num)))\n            if (mod(num, i) == 0) then\n              isprime = .false.\n              return\n            end if\n          end do\n      \n          isprime = .true.\n        end function is_prime\n      \n      \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(5,[2,3])\n    call test(6,[2,3,5])\n    call test(7,[2,3,5])\n    call test(10,[2,3,5,7])\n    call test(22,[2,3,5,7,11,13,17,19])\n    call test(18,[2,3,5,7,11,13,17])\n    call test(47,[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n    call test(101,[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])\n    !call test(1)\n    !call test(0)\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = count_up_to(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main"}
{"task_id": "test/97", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction multiply(num1, num2) result(result)\n!your code\nend function multiply\nEND MODULE test_module \"\n functionality:\nComplete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function multiply(num1, num2) result(result)\n        integer, intent(in) :: num1, num2\n        integer :: result\n    \n        result = mod(abs(num1), 10) * mod(abs(num2), 10)\n    end function multiply\n    \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(148, 412,16)\n    call test(19, 28,72)\n    call test(2020, 1851,0)\n    call test(14,-15,20)\n    call test(76, 67,42)\n    call test(17, 27,49)\n    call test(0, 1,0)\n    call test(0, 0,0)\n    contains\n    subroutine test (r1,r2,ra)\n        implicit none\n            INTEGER, intent(in) :: r1,r2\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = multiply(r1,r2)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/100", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nFUNCTION make_a_pile(n) result(pile)\n!your code\nend FUNCTION make_a_pile\nEND MODULE test_module \"\n functionality:\nGiven a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    FUNCTION make_a_pile(n) result(pile)\n        INTEGER, intent(in) :: n\n        INTEGER, DIMENSION(:), ALLOCATABLE :: pile\n        INTEGER :: i, num_stones\n    \n        allocate(pile(n))\n    \n        num_stones = n\n        do i = 1, n\n            pile(i) = n+2*(i-1)\n        end do\n    end FUNCTION make_a_pile\n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3,[3, 5, 7])\n    call test(4,[4,6,8,10])\n    call test(5,[5, 7, 9, 11, 13])\n    call test(6,[6, 8, 10, 12, 14, 16])\n    call test(8,[8, 10, 12, 14, 16, 18, 20, 22])\n\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = make_a_pile(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main"}
{"task_id": "test/102", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction choose_num(x, y) result(max_even)\n!your code\nend function choose_num\nEND MODULE test_module \"\n functionality:\nThis function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function choose_num(x, y) result(max_even)\n        integer, intent(in) :: x, y\n        integer :: max_even, i\n    \n        max_even = -1\n        do i = y, x, -1\n            if (mod(i, 2) == 0) then\n                max_even = i\n                exit\n            end if\n        end do\n    end function choose_num\n    \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(12, 15,14)\n    call test(13, 12,-1)\n    call test(33, 12354,12354)\n    call test(5234, 5233,-1)\n    call test(6, 29,28)\n    call test(27, 10,-1)\n    call test(7, 7,-1)\n    call test(546, 546,546)\n\n    contains\n    subroutine test (r1,r2,ra)\n        implicit none\n            INTEGER, intent(in) :: r1,r2\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = choose_num(r1,r2)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/106", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction f(n) result(res)\n!your code\nend function f\nEND MODULE test_module \"\n functionality:\nImplement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n ", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function f(n) result(res)\n        integer, intent(in) :: n\n        integer, dimension(n) :: res\n        integer :: i, j, factorial, sum\n      \n        do i = 1, n\n          if (mod(i, 2) == 0) then\n            factorial = 1\n            do j = 1, i\n              factorial = factorial * j\n            end do\n            res(i) = factorial\n          else\n            sum = 0\n            do j = 1, i\n              sum = sum + j\n            end do\n            res(i) = sum\n          end if\n        end do\n      \n      end function f\n      \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(5,[1, 2, 6, 24, 15])\n    call test(7,[1, 2, 6, 24, 15, 720, 28])\n    call test(1,[1])\n    call test(3,[1, 2, 6])\n    \n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = f(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main"}
{"task_id": "test/107", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction even_odd_palindrome(n) result(res)\n!your code\nend function even_odd_palindrome\nEND MODULE test_module \"\n functionality:\nGiven a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    ", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function even_odd_palindrome(n) result(res)\n        integer, intent(in) :: n\n        integer :: i, count_even, count_odd\n        INTEGER, DIMENSION(2) :: res\n        logical :: is_palindrome\n      \n        count_even = 0\n        count_odd = 0\n      \n        do i = 1, n\n          is_palindrome = check_palindrome(i)\n          if (is_palindrome) then\n            if (mod(i, 2) == 0) then\n              count_even = count_even + 1\n            else\n              count_odd = count_odd + 1\n            end if\n          end if\n        end do\n      \n        res(1) = count_even\n        res(2) = count_odd\n      end function even_odd_palindrome\n      \n      function check_palindrome(num) result(check)\n        integer, intent(in) :: num\n        integer :: original, reversed, remainder, tmp\n        logical :: check\n      \n        original = num\n        tmp = num\n        reversed = 0\n      \n        do while (tmp > 0)\n          remainder = mod(tmp, 10)\n          reversed = reversed * 10 + remainder\n          tmp = tmp / 10\n        end do\n      \n        if (original == reversed) then\n          check = .true.\n        else\n          check = .false.\n        end if\n      end function check_palindrome\n      \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(123,[8, 13])\n    call test(12,[4, 6])\n    call test(3,[1, 2])\n    call test(63,[6, 8])\n    call test(25,[5, 6])\n    call test(19,[4, 6])\n    call test(9,[4, 5])\n    call test(1,[0, 1])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = even_odd_palindrome(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main"}
{"task_id": "test/108", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction count_nums(arr) result(count)\n!your code\nend function count_nums\nEND MODULE test_module \"\n functionality:\nWrite a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function count_nums(arr) result(count)\n        integer, intent(in) :: arr(:)\n        integer :: count, i, num, digit_sum\n      \n        count = 0\n        do i = 1, size(arr)\n          num = ABS(arr(i))\n          digit_sum = 0\n          do while (num /= 0)\n            if (num >= 10) then\n              digit_sum = digit_sum + mod(num, 10)\n            else\n              digit_sum = digit_sum + mod(num, 10)*(arr(i)/ABS(arr(i)))\n            end if\n            num = num / 10\n          end do\n      \n          if (digit_sum > 0) then\n            count = count + 1\n          endif\n        end do\n      \n      end function count_nums\n      \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([-1, -2, 0],0)\n    call test([1, 1, 2, -2, 3, 4, 5],6)\n    call test([1, 6, 9, -6, 0, 1, 5],5)\n    call test([1, 100, 98, -7, 1, -1],4)\n    call test([12, 23, 34, -45, -56, 0],5)\n    call test([-0, 1],1)\n    call test([1],1)\n\n    contains\n    subroutine test (r,ra)\n        implicit none\n            integer, intent(in) :: r(:)\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = count_nums(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/109", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction move_one_ball(arr) result(is_sorted)\n!your code\nend function move_one_ball\nEND MODULE test_module \"\n functionality:\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n ", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function move_one_ball(arr) result(is_sorted)\n      implicit none\n      logical :: is_sorted\n      integer, dimension(:), intent(in) :: arr\n      integer :: i, min_value, min_index, n\n      integer, dimension(size(arr)) :: sorted_array, my_arr\n  \n      n = size(arr)\n  \n      if (n == 0) then\n          is_sorted = .true.\n          return\n      end if\n  \n      sorted_array = sort(arr)\n      my_arr = arr\n  \n      min_value = minval(arr)\n      min_index = minloc(arr, dim=1)\n  \n      my_arr = [arr(min_index:n), arr(1:min_index-1)]\n  \n      do i = 1, n\n          if (my_arr(i) /= sorted_array(i)) then\n              is_sorted = .false.\n              return\n          end if\n      end do\n  \n      is_sorted = .true.\n  end function move_one_ball\n\n  function sort(arr) result(sorted_arr)\n    implicit none\n    integer, dimension(:), intent(in) :: arr\n    integer, dimension(size(arr)) :: sorted_arr\n    integer :: i, j, temp\n    integer :: n\n\n\n    sorted_arr = arr\n\n\n    n = size(sorted_arr)\n\n\n    do i = 1, n-1\n        do j = 1, n-i\n            if (sorted_arr(j) > sorted_arr(j+1)) then\n                temp = sorted_arr(j)\n                sorted_arr(j) = sorted_arr(j+1)\n                sorted_arr(j+1) = temp\n            end if\n        end do\n    end do\nend function sort\n      \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([3, 4, 5, 1, 2], .true.)\n    call test([3, 5, 10, 1, 2], .true.)\n    call test([4, 3, 1, 2], .false.)\n    call test([3, 5, 4, 1, 2], .false.)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, dimension(:), intent(in) :: r\n            logical, intent(in) :: ra\n            logical :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = move_one_ball(r)\n            if (a.neqv.ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/114", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction minSubArraySum(nums) result(min_sum)\n!your code\nend function minSubArraySum\nEND MODULE test_module \"\n functionality:\nGiven an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function minSubArraySum(nums) result(min_sum)\n      implicit none\n      integer, dimension(:), intent(in) :: nums\n      integer :: min_sum, max_sum, s, num\n      integer :: i, n\n  \n      n = size(nums)\n  \n      max_sum = 0\n      s = 0\n  \n      do i = 1, n\n          num = -nums(i)\n          s = s + num\n  \n          if (s < 0) then\n              s = 0\n          end if\n  \n          max_sum = max(s, max_sum)\n      end do\n  \n      if (max_sum == 0) then\n          max_sum = maxval(-nums)\n      end if\n  \n      min_sum = -max_sum\n  end function minSubArraySum\n      \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([2, 3, 4, 1, 2, 4],1)\n    call test([-1, -2, -3],-6)\n    call test([-1, -2, -3, 2, -10],-14)\n    !call test([-9999999999999999])\n    call test([0, 10, 20, 1000000],0)\n    call test([-1, -2, -3, 10, -5],-6)\n    call test([100, -1, -2, -3, 10, -5],-6)\n    call test([10, 11, 13, 8, 3, 4],3)\n    call test([100, -33, 32, -1, 0, -2],-33)\n    call test([-10],-10)\n    call test([7],7)\n    call test([1, -1],-1)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, dimension(:), intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = minSubArraySum(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/120", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction maximum(arr, k) result(ans)\n!your code\nend function maximum\nEND MODULE test_module \"\n functionality:\nGiven an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function maximum(arr, k) result(ans)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: k\n        integer, dimension(:), allocatable :: sorted_arr, ans\n        integer :: n\n    \n        if (k == 0) then\n            allocate(ans(0))\n            return\n        end if\n    \n        n = size(arr)\n    \n        allocate(sorted_arr(n))\n        sorted_arr = arr\n        call quicksort(sorted_arr, 1, n)\n    \n        allocate(ans(k))\n        ans = sorted_arr(n-k+1:n)\n    \n    contains\n    \n        RECURSIVE subroutine quicksort(arr, low, high)\n            implicit none\n            integer, dimension(:), intent(inout) :: arr\n            integer, intent(in) :: low, high\n            integer :: i, j, pivot, temp\n    \n            if (low < high) then\n                pivot = arr(high)\n                i = low - 1\n    \n                do j = low, high-1\n                    if (arr(j) <= pivot) then\n                        i = i + 1\n                        temp = arr(i)\n                        arr(i) = arr(j)\n                        arr(j) = temp\n                    end if\n                end do\n    \n                temp = arr(i+1)\n                arr(i+1) = arr(high)\n                arr(high) = temp\n    \n                call quicksort(arr, low, i)\n                call quicksort(arr, i+2, high)\n            end if\n        end subroutine quicksort\n    \n    end function maximum\n    \n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([-3, -4, 5], 3,[-4, -3, 5])\n    call test([4, -4, 4], 2,[4, 4])\n    call test([-3, 2, 1, 2, -1, -2, 1], 1,[2])\n    call test([123, -123, 20, 0 , 1, 2, -3], 3,[2, 20, 123])\n    call test([-123, 20, 0 , 1, 2, -3], 4,[0, 1, 2, 20])\n    call test([5, 15, 0, 3, -13, -8, 0], 7,[-13, -8, 0, 0, 3, 5, 15])\n    call test([-1, 0, 2, 5, 3, -10], 2,[3, 5])\n    call test([1, 0, 5, -7], 1,[5])\n    call test([4, -4], 2,[-4, 4])\n    call test([-10, 10], 2,[-10, 10])\n    !call test([1, 2, 3, -23, 243, -400, 0], 0)\n\n    contains\n  subroutine test (p1, p2, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: p1\n  INTEGER, INTENT(IN) :: p2\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = maximum(p1, p2)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main"}
{"task_id": "test/121", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction sum_odd_elements(arr) result(sum)\n!your code\nend function sum_odd_elements\nEND MODULE test_module \"\n functionality:\nGiven a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function sum_odd_elements(arr) result(sum)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: sum, i\n    \n        sum = 0\n        do i = 1, size(arr), 2\n            if (mod(arr(i), 2) /= 0) then\n                sum = sum + arr(i)\n            end if\n        end do\n    \n    end function sum_odd_elements\n    \n    \n    \nEND MODULE test_module","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([5, 8, 7, 1],12)\n    call test([3, 3, 3, 3, 3],9)\n    call test([30, 13, 24, 321],0)\n    call test([5, 9],5)\n    call test([2, 4, 8],0)\n    call test([30, 13, 23, 32],23)\n    call test([3, 13, 2, 9],3)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, dimension(:), intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = sum_odd_elements(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main"}
{"task_id": "test/122", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction add_elements(arr, k) result(sum)\n!your code\nend function add_elements\nEND MODULE test_module \"\n functionality:\nGiven a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function add_elements(arr, k) result(sum)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in) :: k\n        integer :: sum, i, count\n    \n        sum = 0\n        count = 0\n        do i = 1, k\n            if (abs(arr(i)) < 100) then\n                sum = sum + arr(i)\n                count = count + 1\n            end if\n        end do\n    \n    end function add_elements\n    \nEND MODULE test_module  ","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1,-2,-3,41,57,76,87,88,99], 3, -4)\n    call test([111,121,3,4000,5,6], 2, 0)\n    call test([11,21,3,90,5,6,7,8,9], 4, 125)\n    call test([111,21,3,4000,5,6,7,8,9], 4, 24)\n    call test([1], 1, 1)\n    contains\n    subroutine test (r1, r2,ra)\n        implicit none\n            INTEGER, dimension(:), intent(in) :: r1\n            INTEGER, intent(in) :: r2\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = add_elements(r1,r2)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/123", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction get_odd_collatz(n) result(odd_list)\n!your code\nend function get_odd_collatz\nEND MODULE test_module \"\n functionality:\nGiven a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function get_odd_collatz(n) result(odd_list)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: odd_list\n        integer :: num, count\n    \n        allocate(odd_list(n))\n        count = 0\n        num = n\n        do while (num > 1)\n            if (mod(num, 2) == 1) then\n                count = count + 1\n                odd_list(count) = num\n            end if\n            if (mod(num, 2) == 0) then\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end if\n        end do\n        count = count + 1\n        odd_list(count) = 1\n        odd_list = odd_list(1:count)\n        call sort_odd_list(odd_list)\n    \n    contains\n    \n        subroutine sort_odd_list(list)\n            implicit none\n            integer, dimension(:), intent(inout) :: list\n            integer :: i, j, temp\n    \n            do i = 1, size(list)-1\n                do j = i+1, size(list)\n                    if (list(i) > list(j)) then\n                        temp = list(i)\n                        list(i) = list(j)\n                        list(j) = temp\n                    end if\n                end do\n            end do\n    \n        end subroutine sort_odd_list\n    \n    end function get_odd_collatz\n    \n       \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(14, [1, 5, 7, 11, 13, 17])\n    call test(5, [1, 5])\n    call test(12, [1, 3, 5])\n    call test(1, [1])\n    \n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = get_odd_collatz(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main  \n"}
{"task_id": "test/126", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction is_sorted(lst) result(sorted)\n!your code\nend function is_sorted\nEND MODULE test_module \"\n functionality:\nGiven a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function is_sorted(lst) result(sorted)\n        implicit none\n        integer, dimension(:), intent(in) :: lst\n        logical :: sorted\n        integer, dimension(:), allocatable :: count_digit\n        integer :: i, n\n    \n        n = size(lst)\n    \n        allocate(count_digit(n))\n        count_digit = 0\n    \n        do i = 1, n\n            count_digit(lst(i)) = count_digit(lst(i)) + 1\n        end do\n    \n        if (any(count_digit > 2)) then\n            sorted = .false.\n            return\n        end if\n    \n        sorted = all(lst(1:n-1) <= lst(2:n))\n    end function is_sorted\n    \n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([5], .true.)\n    call test([1, 2, 3, 4, 5], .true.)\n    call test([1, 3, 2, 4, 5], .false.)\n    call test([1, 2, 3, 4, 5, 6], .true.)\n    call test([1, 2, 3, 4, 5, 6, 7], .true.)\n    call test([1, 3, 2, 4, 5, 6, 7], .false.)\n    !call test([], , .true.)\n    call test([1], .true.)\n    call test([3, 2, 1], .false.)\n    call test([1, 2, 2, 2, 3, 4], .false.)\n    call test([1, 2, 3, 3, 3, 4], .false.)\n    call test([1, 2, 2, 3, 3, 4], .true.)\n    call test([1, 2, 3, 4], .true.)\n\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = is_sorted(r)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/128", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction prod_signs(arr) result(result_sum)\n!your code\nend function prod_signs\nEND MODULE test_module \"\n functionality:\nYou are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function prod_signs(arr) result(result_sum)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: i\n        integer :: product_sign, sum_magnitudes, result_sum\n    \n        if (size(arr) == 0) then\n            result_sum = 0\n            return\n        end if\n    \n        product_sign = 1\n        sum_magnitudes = 0\n    \n        do i = 1, size(arr)\n            if (arr(i) > 0) then\n                product_sign = product_sign * 1\n            else if (arr(i) < 0) then\n                product_sign = product_sign * (-1)\n            else\n                product_sign = product_sign * 0\n            end if\n    \n            sum_magnitudes = sum_magnitudes + abs(arr(i))\n        end do\n    \n        result_sum = sum_magnitudes * product_sign\n    \n    end function prod_signs\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test([1, 2, 2, -4],-9)\n    call test([0, 1],0)\n    call test([1, 1, 1, 2, 3, -1, 1],-10)\n    call test([2, 4,1, 2, -1, -1, 9],20)\n    call test([-1, 1, -1, 1],4)\n    call test([-1, 1, 1, 1],-4)\n    call test([-1, 1, 1, 0],0)\n    \n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, dimension(:), intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = prod_signs(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/130", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction tri(n) result(my_tri)\n!your code\nend function tri\nEND MODULE test_module \"\n functionality:\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function tri(n) result(my_tri)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), allocatable :: my_tri\n        integer :: i\n    \n        if (n == 0) then\n            allocate(my_tri(1))\n            my_tri(1) = 1\n            return\n        end if\n    \n        allocate(my_tri(n + 1))\n        my_tri(1) = 1\n        my_tri(2) = 3\n    \n        do i = 3, n+1\n            if (mod(i-1, 2) == 0) then\n                my_tri(i) = (i-1)/ 2 + 1\n            else\n                my_tri(i) = my_tri(i - 1) + my_tri(i - 2) + (i-1 + 3) / 2\n            end if\n        end do\n    \n    end function tri\nEND MODULE test_module \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3,[1, 3, 2, 8])\n    call test(4,[1, 3, 2, 8, 3])\n    call test(5,[1, 3, 2, 8, 3, 15])\n    call test(6,[1, 3, 2, 8, 3, 15, 4])\n    call test(7,[1, 3, 2, 8, 3, 15, 4, 24])\n    call test(8,[1, 3, 2, 8, 3, 15, 4, 24, 5])\n    call test(9,[1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\n    call test(20,[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\n    call test(0,[1])\n    call test(1,[1,3])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = tri(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/131", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction digits1(m) result(product)\n!your code\nend function digits1\nEND MODULE test_module \"\n functionality:\nGiven a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits1(1)  == 1\n    digits1(4)  == 0\n    digits1(235) == 15\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function digits1(m) result(product)\n        implicit none\n        integer, intent(in) :: m\n        integer :: product, odd_count, int_digit, n\n        character(len=1) :: digit\n    \n        product = 1\n        odd_count = 0\n        n = m\n    \n        do while (n /= 0)\n            digit = char(mod(n, 10) + 48)\n            int_digit = ichar(digit) - 48\n    \n            if (mod(int_digit, 2) == 1) then\n                product = product * int_digit\n                odd_count = odd_count + 1\n            end if\n    \n            n = n / 10\n        end do\n    \n        if (odd_count == 0) then\n            product = 0\n        end if\n    end function digits1\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(5,5)\n    call test(54,5)\n    call test(120,1)\n    call test(5014,5)\n    call test(98765,315)\n    call test(5576543,2625)\n    call test(2468,0)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = digits1(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n \n"}
{"task_id": "test/133", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction sum_squares(lst) result(total)\n!your code\nend function sum_squares\nEND MODULE test_module \"\n functionality:\nYou are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function sum_squares(lst) result(total)\n        implicit none\n        real, dimension(:), intent(in) :: lst\n        integer :: i, total\n    \n        total = 0\n    \n        do i = 1, size(lst)\n            total = total + ceiling(lst(i))**2\n        end do\n    \n    end function sum_squares\n    \nEND MODULE test_module \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1.0,2.0,3.0],14)\n    call test([1.0,2.0,3.0],14)\n    call test([1.0,3.0,5.0,7.0],84)\n    call test([1.4,4.2,0.0],29)\n    call test([-2.4,1.0,1.0],6)\n    call test([100.0,1.0,15.0,2.0],10230)\n    call test([10000.0,10000.0],200000000)\n    call test([-1.4,4.6,6.3],75)\n    call test([-1.4,17.9,18.9,19.9],1086)\n    call test([0.0],0)\n    call test([-1.0],1)\n    call test([-1.0,1.0,0.0],2)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      real, DIMENSION(:), INTENT(IN) :: r\n      INTEGER, intent(in) :: ra\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = sum_squares(r)\n      if (a/=ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/135", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction can_arrange(arr) result(ind)\n!your code\nend function can_arrange\nEND MODULE test_module \"\n functionality:\nCreate a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function can_arrange(arr) result(ind)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: ind, i\n    \n        ind = -1\n        i = 2\n    \n        do while (i <= size(arr))\n            if (arr(i) < arr(i-1)) then\n                ind = i-1\n            end if\n            i = i + 1\n        end do\n    \n    end function can_arrange\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1,2,4,3,5],3)\n    call test([1,2,4,5],-1)\n    call test([1,4,2,5,6,7,8,9,10],2)\n    call test([4,8,5,7,3],4)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, dimension(:), intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = can_arrange(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/138", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction is_equal_to_sum_even(n) result(is_equal)\n!your code\nend function is_equal_to_sum_even\nEND MODULE test_module \"\n functionality:\nEvaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function is_equal_to_sum_even(n) result(is_equal)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i, j, k, l\n        logical :: is_equal\n    \n        is_equal = .false.\n        do i = 2, n-6, 2\n            do j = i, n-i-4, 2\n                do k = j, n-i-j-2, 2\n                    l = n - i - j - k\n                    if (mod(l, 2) == 0 .and. l > 0) then\n                        is_equal = .true.\n                        return\n                    end if\n                end do\n            end do\n        end do\n    \n    end function is_equal_to_sum_even\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(4, .false.)\n    call test(6, .false.)\n    call test(8, .true.)\n    call test(10, .true.)\n    call test(11, .false.)\n    call test(12, .true.)\n    call test(13, .false.)\n    call test(16, .true.)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            logical, intent(in) :: ra\n            logical :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = is_equal_to_sum_even(r)\n            if (a.neqv.ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n \n"}
{"task_id": "test/139", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction brazilian_factorial(n) result(factorial)\n!your code\nend function brazilian_factorial\nEND MODULE test_module \"\n functionality:\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function brazilian_factorial(n) result(factorial)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i, j, factorial\n    \n        factorial = 1\n        do i = n, 1, -1\n            do j = i, 1, -1\n                factorial = factorial * j\n            end do\n        end do\n    \n    end function brazilian_factorial\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(4,288)\n    call test(5,34560)\n    !call test(7,125411328000) too large\n    call test(1,1)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = brazilian_factorial(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/142", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction sum_squares(inp) result(sum)\n!your code\nend function sum_squares\nEND MODULE test_module \"\n functionality:\nThis function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function sum_squares(inp) result(sum)\n        implicit none\n        integer, intent(in) :: inp(:)\n        integer, dimension(:), allocatable :: lst\n        integer :: i, n, sum\n    \n        n = size(inp)\n        allocate(lst(n))\n        sum = 0\n    \n        do i = 1, n\n            lst(i) = inp(i)\n            if (mod(i-1, 3) == 0) then\n                lst(i) = lst(i) ** 2\n            elseif (mod(i-1, 4) == 0 .and. mod(i-1, 3) /= 0) then\n                lst(i) = lst(i) ** 3\n            end if\n    \n            sum = sum + lst(i)\n        end do\n    \n    end function sum_squares    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1,2,3],6)\n    call test([1,4,9],14)\n    call test([1,1,1,1,1,1,1,1,1],9)\n    call test([-1,-1,-1,-1,-1,-1,-1,-1,-1],-3)\n    call test([0],0)\n    call test([-1,-5,2,-1,-5],-126)\n    call test([-56,-99,1,0,-2],3030)\n    call test([-1,0,0,0,0,0,0,0,-1],0)\n    call test([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37],-14196)\n    call test([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10],-1448)\n    contains\n  subroutine test (r,ra)\n  implicit none\n      INTEGER, DIMENSION(:), INTENT(IN) :: r\n      INTEGER, intent(in) :: ra\n      INTEGER :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = sum_squares(r)\n      if (a/=ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main \n"}
{"task_id": "test/146", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction specialFilter(arr) result(count)\n!your code\nend function specialFilter\nEND MODULE test_module \"\n functionality:\nWrite a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function specialFilter(arr) result(count)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        integer :: count, i, num, first_digit, last_digit\n    \n        count = 0\n    \n        do i = 1, size(arr)\n            num = abs(arr(i))\n            first_digit = abs(mod(num, 10))\n            last_digit = abs(num / 10 ** int(log10(real(num))) )\n    \n            if (arr(i) > 10 .and. odd_digit(first_digit) .and. odd_digit(last_digit)) then\n                count = count + 1\n            end if\n        end do\n    \n    contains\n    \n        function odd_digit(digit) result(is_odd)\n            implicit none\n            integer, intent(in) :: digit\n            logical :: is_odd\n    \n            is_odd = digit == 1 .or. digit == 3 .or. digit == 5 .or. digit == 7 .or. digit == 9\n        end function odd_digit\n    \n    end function specialFilter    \nEND MODULE test_module   \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([5, -2, 1, -5],0)\n    call test([15, -73, 14, -15],1)\n    call test([33, -2, -3, 45, 21, 109],2)\n    call test([43, -12, 93, 125, 121, 109],4)\n    call test([71, -2, -33, 75, 21, 19],3)\n    call test([1],0)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, DIMENSION(:), INTENT(IN) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = specialFilter(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main \n"}
{"task_id": "test/147", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction get_max_triples(n) result(count)\n!your code\nend function get_max_triples\nEND MODULE test_module \"\n functionality:\nYou are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function get_max_triples(n) result(count)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(n) :: a\n        integer :: count, i, j, k\n    \n        count = 0\n    \n        do i = 1, n\n            a(i) = i * i - i + 1\n        end do\n    \n        do i = 1, n - 2\n            do j = i + 1, n - 1\n                do k = j + 1, n\n                    if (mod(a(i) + a(j) + a(k), 3) == 0) then\n                        count = count + 1\n                    end if\n                end do\n            end do\n        end do\n    \n    end function get_max_triples\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(5,1)\n    call test(6,4)\n    call test(10,36)\n    call test(100,53361)\n    contains\n    subroutine test (r,ra)\n        implicit none\n            INTEGER, intent(in) :: r\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = get_max_triples(r)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n"}
{"task_id": "test/150", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction x_or_y(n, x, y) result(result_value)\n!your code\nend function x_or_y\nEND MODULE test_module \"\n functionality:\nA simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function x_or_y(n, x, y) result(result_value)\n        implicit none\n        integer, intent(in) :: n, x, y\n        integer :: result_value, i, is_prime\n    \n        is_prime = 1\n    \n        if (n <= 1) then\n            is_prime = 0\n        else\n            do i = 2, n - 1\n                if (mod(n, i) == 0) then\n                    is_prime = 0\n                    exit\n                end if\n            end do\n        end if\n    \n        if (is_prime == 1) then\n            result_value = x\n        else\n            result_value = y\n        end if\n    \n    end function x_or_y\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(7, 34, 12,34)\n    call test(15, 8, 5,5)\n    call test(3, 33, 5212,33)\n    call test(1259, 3, 52,3)\n    call test(7919, -1, 12,-1)\n    call test(3609, 1245, 583,583)\n    call test(91, 56, 129,129)\n    call test(6, 34, 1234,1234)\n    call test(1, 2, 0,0)\n    call test(2, 2, 0,2)\n    contains\n    subroutine test (r1,r2,r3,ra)\n        implicit none\n            INTEGER, intent(in) :: r1,r2,r3\n            INTEGER, intent(in) :: ra\n            INTEGER :: a\n            logical :: exists\n            inquire(file='result.txt', exist=exists)\n            a = x_or_y(r1,r2,r3)\n            if (a/=ra) then\n                if (exists) then\n                  open(1, file = 'result.txt', status='old')\n                else\n                  open(1, file = 'result.txt', status='new')\n                end if\n                write(1,*)'F', a, ra\n            end if\n        end subroutine\nEND PROGRAM main\n \n"}
{"task_id": "test/152", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction compare(scores, guesses) result(diff)\n!your code\nend function compare\nEND MODULE test_module \"\n functionality:\nI think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function compare(scores, guesses) result(diff)\n        implicit none\n        integer, dimension(:), intent(in) :: scores, guesses\n        integer, dimension(:), allocatable :: diff\n        integer :: i, n\n    \n        n = size(scores)\n        allocate(diff(n))\n    \n        do i = 1, n\n            if (scores(i) == guesses(i)) then\n                diff(i) = 0\n            else\n                diff(i) = abs(scores(i) - guesses(i))\n            end if\n        end do\n    \n    end function compare\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test([1,2,3,4,5,1],[1,2,3,4,2,-2],[0,0,0,0,3,3])\n    call test([0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0])\n    call test([1,2,3],[-1,-2,-3],[2,4,6])\n    call test([1,2,3,5],[-1,2,3,4],[2,0,0,1])\n    contains\n  subroutine test (r1,r2, ra)\n  implicit none\n  INTEGER, DIMENSION(:), INTENT(IN) :: r1,r2\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = compare(r1,r2)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/155", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction even_odd_count(m) result(count)\n!your code\nend function even_odd_count\nEND MODULE test_module \"\n functionality:\nGiven an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function even_odd_count(m) result(count)\n        implicit none\n        integer, intent(in) :: m\n        integer :: count(2), digit, n\n    \n        count = 0\n        n=m\n        if(n==0) then\n            count(1)=1\n            return\n        end if\n        do while (n /= 0)\n            digit = abs(mod(n, 10))\n    \n            if (mod(digit, 2) == 0) then\n                count(1) = count(1) + 1  ! even count\n            else\n                count(2) = count(2) + 1  ! odd count\n            end if\n    \n            n = n / 10\n        end do\n    \n    end function even_odd_count\nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(7,[0, 1])\n    call test(-78,[1, 1])\n    call test(3452,[2, 2])\n    call test(346211,[3, 3])\n    call test(-345821,[3, 3])\n    call test(-2,[1, 0])\n    call test(-45347,[2, 3])\n    call test(0,[1, 0])\n    contains\n  subroutine test (r, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = even_odd_count(r)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n"}
{"task_id": "test/157", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction right_angle_triangle(a, b, c) result(is_right_angle)\n!your code\nend function right_angle_triangle\nEND MODULE test_module \"\n functionality:\nGiven the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function right_angle_triangle(a, b, c) result(is_right_angle)\n        implicit none\n        integer, intent(in) :: a, b, c\n        logical :: is_right_angle\n    \n        is_right_angle = a*a + b*b == c*c .or. a*a + c*c == b*b .or. b*b + c*c == a*a\n    \n    end function right_angle_triangle\n    \nEND MODULE test_module  \n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(3, 4, 5, .true.)\n    call test(1, 2, 3, .false.)\n    call test(10, 6, 8, .true.)\n    call test(2, 2, 2, .false.)\n    call test(7, 24, 25, .true.)\n    call test(10, 5, 7, .false.)\n    call test(5, 12, 13, .true.)\n    call test(15, 8, 17, .true.)\n    call test(48, 55, 73, .true.)\n    contains\n  subroutine test (r1,r2,r3,ra)\n  implicit none\n      INTEGER, INTENT(IN) :: r1,r2,r3\n      LOGICAL, intent(in) :: ra\n      LOGICAL :: a\n      logical :: exists\n      inquire(file='result.txt', exist=exists)\n      a = right_angle_triangle(r1,r2,r3)\n      if (a.neqv.ra) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\nEND PROGRAM main \n"}
{"task_id": "test/159", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction eat(number, need, remaining) result(result_arr)\n!your code\nend function eat\nEND MODULE test_module \"\n functionality:\nYou're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n \n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function eat(number, need, remaining) result(result_arr)\n        implicit none\n        integer, intent(in) :: number, need, remaining\n        integer, dimension(2) :: result_arr\n    \n        if (need <= remaining) then\n            result_arr(1) = number + need\n            result_arr(2) = remaining - need\n        else\n            result_arr(1) = number + remaining\n            result_arr(2) = 0\n        end if\n    \n    end function eat\nEND MODULE test_module  \n\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n    call test(5, 6, 10, [11, 4])\n    call test(4, 8, 9, [12, 1])\n    call test(1, 10, 10, [11, 0])\n    call test(2, 11, 5, [7, 0])\n    call test(4, 5, 7, [9, 2])\n    call test(4, 5, 1, [5, 0])\n    contains\n  subroutine test (r1, r2, r3, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r1,r2,r3\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = eat(r1, r2, r3)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main \n\n"}
{"task_id": "test/163", "prompt": "Please complete the following code based on Fortran 90's function to achieve the described functionality, and you should give me the code without any other words.\n code:\"MODULE test_module\nCONTAINS \nfunction generate_integers(a, b) result(integers)\n!your code\nend function generate_integers\nEND MODULE test_module \"\n functionality:\nGiven two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n", "canonical_solution": "MODULE test_module\n    CONTAINS \n    function generate_integers(a, b) result(integers)\n        implicit none\n        integer, intent(in) :: a, b\n        integer, dimension(:), allocatable :: integers\n        integer :: lower, upper, i, count\n    \n        lower = max(2, min(a, b))\n        upper = min(8, max(a, b))\n    \n        count = 0\n        do i = lower, upper\n            if (mod(i, 2) == 0) then\n                count = count + 1\n            end if\n        end do\n    \n        allocate(integers(count))\n        count = 0\n        do i = lower, upper\n            if (mod(i, 2) == 0) then\n                count = count + 1\n                integers(count) = i\n            end if\n        end do\n    \n    end function generate_integers\nEND MODULE test_module  \n\n","test": "PROGRAM main\n    USE test_module\n    IMPLICIT NONE\n\n    call test(2, 10, [2, 4, 6, 8])\n    call test(10, 2, [2, 4, 6, 8])\n    call test(132, 2, [2, 4, 6, 8])\n    !call test(17,89, [])\n    contains\n  subroutine test (r1, r2, ra)\n  implicit none\n  INTEGER, INTENT(IN) :: r1, r2\n  INTEGER, DIMENSION(:), INTENT(IN) :: ra\n  INTEGER, DIMENSION(:), ALLOCATABLE:: a\n      logical :: exists\n      logical :: result\n      inquire(file='result.txt', exist=exists)\n      a = generate_integers(r1,r2)\n      call judge(a, ra, result)\n      if (result.eqv. .false.) then\n          if (exists) then\n            open(1, file = 'result.txt', status='old')\n          else\n            open(1, file = 'result.txt', status='new')\n          end if\n          write(1,*)'F', a, ra\n      end if\n  end subroutine\n\n  subroutine judge(arr1, arr2,result) \n    INTEGER, DIMENSION(:), INTENT(IN) :: arr1, arr2\n    LOGICAL, intent(INOUT) :: result\n    INTEGER :: i\n    \n    result = .TRUE.\n    IF (SIZE(arr1) /= SIZE(arr2)) THEN\n        result = .FALSE.\n        RETURN\n    END IF\n    \n    DO i = 1, SIZE(arr1)\n        IF (arr1(i) /= arr2(i)) THEN\n            result = .FALSE.\n            RETURN\n        END IF\n    END DO\nEND subroutine judge\nEND PROGRAM main\n\n"}
